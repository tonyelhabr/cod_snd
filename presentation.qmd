---
title: "They're Clutching up! Team Momentum in Round-Based Esports"
author: 'Tony ElHabr'
format:
  revealjs:
    slide-number: true
    incremental: false
    theme: [dark, theme.scss]
execute: 
  include: false
  echo: false
  eval: false
---

```{r}
#| label: setup
#| eval: true
library(dplyr)
library(dplyr)
library(qs)
library(scales)

cod_rounds <- qs::qread('cod_rounds.qs')
val_rounds <- qs::qread('valorant_rounds.qs')
```

```{r}
#| label: setup-eval
library(tidyverse)
library(extrafont)
library(ggtext)
library(ggsci)
library(ggnewscale)
library(magick)
library(broom)
library(knitr)

blackish_background <- '#191919' ## to match slide background
gray_points <- '#4d4d4d'
gray_text <- '#999999'

font <- 'Titillium Web'
extrafont::loadfonts(quiet = TRUE)
theme_set(theme_minimal())
theme_update(
  text = element_text(family = font),
  title = element_text(size = 14, color = 'white'),
  plot.title = element_text(face = 'bold', size = 20, color = 'white'),
  plot.title.position = 'plot',
  plot.subtitle = element_text(size = 14, color = '#f1f1f1'),
  axis.text = element_text(color = 'white', size = 14),
  axis.title = element_text(size = 14, color = 'white', face = 'bold', hjust = 0.99),
  axis.line = element_blank(),
  panel.grid.major = element_line(color = gray_points),
  panel.grid.minor = element_line(color = gray_points),
  panel.grid.minor.x = element_blank(),
  panel.grid.minor.y = element_blank(),
  strip.text = element_text(color = 'white', size = 16, face = 'bold'),
  plot.margin = margin(10, 10, 10, 10),
  plot.background = element_rect(fill = blackish_background, color = blackish_background),
  plot.caption = element_text(size = 12, color = 'white', hjust = 1),
  plot.caption.position = 'plot',
  plot.tag = ggtext::element_markdown(size = 12, color = 'white', hjust = 0),
  plot.tag.position = c(0.01, 0.01),
  panel.background = element_rect(fill = blackish_background, color = blackish_background)
)
update_geom_defaults('text', list(family = font, size = 10 / .pt, fontface = 'bold'))
update_geom_defaults('point', list(color = 'white'))
update_geom_defaults('segment', list(color = 'white'))

add_logo <- function(
    path,
    path_logo,
    idx_x,
    idx_y,
    logo_scale = 0.1,
    adjust_x = TRUE,
    adjust_y = TRUE,
    path_suffix = '_w_logo',
    delete = TRUE
) {
  
  plot <- magick::image_read(path)
  logo_raw <- magick::image_read(path_logo)
  
  plot_height <- magick::image_info(plot)$height
  plot_width <- magick::image_info(plot)$width
  
  logo <- magick::image_scale(logo_raw, as.character(round(plot_width * logo_scale)))
  
  info <- magick::image_info(logo)
  logo_width <- info$width
  logo_height <- info$height
  
  x_pos <- plot_width - idx_x * plot_width
  y_pos <- plot_height - idx_y * plot_height
  
  if (adjust_x) {
    x_pos <- x_pos - logo_width
  }
  
  if (adjust_y) {
    y_pos <- y_pos - logo_height
  }
  
  offset <- paste0('+', x_pos, '+', y_pos)
  
  img <- magick::image_composite(plot, logo, offset = offset)
  ext <- tools::file_ext(path)
  rgx_ext <- sprintf('[.]%s$', ext)
  
  res <- magick::image_write(
    img,
    gsub(rgx_ext, sprintf('%s.%s', path_suffix, ext), path)
  )
  
  if (!delete) {
    return(res)
  }
  unlink(path, recursive = TRUE, force = TRUE)
  res
}

```

## Game types

::: fragment
### Search and Destroy (SnD) in Call of Duty (COD)

-   2020-2022 Call of Duty League (CDL) matches (qualifiers and majors)
-   4v4
-   First to 6 round wins
-   Teams swap sides (offense and defense) after every round
:::

<br/>

::: fragment
### A Plant/Defuse in Valorant

-   2021 Valorant Champions Tour (VCT) matches (qualifiers and majors)
-   5v5
-   First to 13 round wins
-   One team plays offense in 12 consecutive rounds before swapping sides
-   Must win by 2 rounds
:::

## How does a team win a round of COD SnD / Valorant plant/defuse?

::: fragment
1.  One team eliminates all members of the other team prior to a bomb plant.
:::

::: fragment
2.  The offensive team eliminates all members of the defensive team after a bomb plant.
:::

::: fragment
3.  The defensive team defuses the bomb after a bomb plant.
:::

::: fragment
Often the defensive team will try to eliminate all team members prior to making the defuse, but in some cases, they may try to "ninja" defuse.
:::

::: fragment
4.  The offensive team does not make a plant by the time the round timer ends.
:::

## COD SnD data overview

```{r}
#| label: descriptive-cod-snd-stats
#| eval: true
cod_n_series <- cod_rounds |> 
  distinct(year, sheet, series) |> 
  nrow() |> 
  scales::comma()

cod_n_rounds <- cod_rounds |> 
  distinct(year, sheet, series, round) |> 
  nrow() |> 
  scales::comma()

cod_o_win_prop_const <- cod_rounds |> 
  filter(is_offense) |> 
  count(win_round) |> 
  mutate(prop = n / sum(n)) |> 
  filter(win_round) |> 
  pull(prop)
cod_o_win_pct <- scales::percent(cod_o_win_prop_const, accuracy = 1)

cod_plant_pct <- cod_rounds |>
  filter(is_offense) |> 
  count(makes_plant = !is.na(plant)) |> 
  mutate(prop = n / sum(n)) |> 
  filter(makes_plant) |> 
  pull(prop) |> 
  scales::percent(accuracy = 1)

cod_o_plant_and_win_pct <- cod_rounds |> 
  filter(is_offense, !is.na(plant)) |> 
  count(win_round) |> 
  mutate(prop = n / sum(n)) |> 
  filter(win_round) |> 
  pull(prop) |> 
  scales::percent(accuracy = 1)

cod_o_first_blood_win_pct <- cod_rounds |> 
  filter(!is.na(earned_fb)) |> 
  filter(earned_fb) |> 
  count(win_round) |> 
  mutate(prop = n / sum(n)) |> 
  filter(win_round) |> 
  pull(prop) |> 
  scales::percent(accuracy = 1)
```

::: fragment
-   Total series: **`r cod_n_series`**
:::

::: fragment
-   Total rounds: **`r cod_n_rounds`**
:::

::: fragment
-   Offensive plant %: **`r cod_plant_pct`**
:::

::: fragment
-   Offensive win %: **`r cod_o_win_pct`**
:::

::: fragment
-   Win % when planting: **`r cod_o_plant_and_win_pct`**
:::

::: fragment
-   Win % when earning first blood: **`r cod_o_first_blood_win_pct`**
:::

## Valorant data overview

```{r}
#| label: descriptive-val-snd-stats
#| eval: true
val_n_series <- val_rounds |> 
  distinct(series_id) |> 
  nrow() |> 
  scales::comma()

val_n_rounds <- val_rounds |> 
  distinct(series_id, round) |> 
  nrow() |> 
  scales::comma()

val_o_win_prop_const <- val_rounds |> 
  filter(is_offense) |> 
  count(win_round) |> 
  mutate(prop = n / sum(n)) |> 
  filter(win_round) |> 
  pull(prop)
val_o_win_pct <- scales::percent(val_o_win_prop_const, accuracy = 0.1)
```

::: fragment
-   Total series: **`r val_n_series`**
:::

::: fragment
-   Total rounds: **`r val_n_rounds`**
:::

::: fragment
-   Offensive win %: **`r val_o_win_pct`**
:::

## What are your chances of winning the next round ([COD SnD]{.cod})?

```{r}
#| label: cod-funcs

common_cod_labs <- function(...) {
  list(
    ...,
    labs(
      caption = 'CDL SnD Major and Weekly matches, 2020 - present'
    )
  )
}

common_cod_heatmap_layers <- function(...) {
  list(
    ...,
    guides(
      fill = 'none'
    ),
    scale_x_continuous(
      labels = 0:5,
      breaks = seq(0.5, 5.5, by = 1),
      expand = c(0, 0)
    ),
    scale_y_continuous(
      labels = 0:5,
      breaks = seq(0.5, 5.5, by = 1),
      expand = c(0, 0),
      sec.axis = sec_axis(
        trans = I, 
        name = ' ', 
        breaks = seq(0.5, 5.5, by = 1), 
        labels = rep('', 6)
      )
    ),
    theme(
      panel.grid.major = element_blank(),
      axis.title = element_text(hjust = 0.5),
      plot.title = ggtext::element_markdown(hjust = 0.5),
      axis.text = element_text(size = 16, face = 'bold')
    ),
    common_cod_labs(),
    labs(
      x = "Offensive Team's # of Pre-Round Wins",
      y = "Defensive Team's # of Pre-Round Wins"
    )
  )
}

.dpi <- 300
save_plot_for_slide <- function(
    p, 
    filename = paste0(str_remove(deparse(substitute(p)), '^p_'), '.png'), 
    width = 7.5, 
    height = width / 1.5,
    units = 'px',
    dpi = .dpi,
    ...
) {
  
  path <- ggsave(
    plot = p,
    filename = file.path('plots', filename),
    width = width * dpi,
    height = height * dpi,
    units = units,
    dpi = dpi,
    ...
  )
  is_cod <- filename |> str_detect('cod_')
  game <- ifelse(is_cod, 'cod', 'val')
  logo_scale <- ifelse(is_cod, 0.15, 0.07)
  add_logo(
    path,
    path_logo = file.path('images', sprintf('%s.png', game)),
    delete = FALSE,
    path_suffix = '',
    logo_scale = logo_scale,
    idx_x = 0.99,
    idx_y = 0.01,
    adjust_x = FALSE
  )
}

heatmap_tile <- function(..., .fill) {
  list(
    ...,
    geom_rect(
      color = blackish_background,
      aes(
        fill = .data[[.fill]],
        xmin = pre_cumu_w, 
        ymin = pre_cumu_l,
        xmax = pre_cumu_w + 1,
        ymax = pre_cumu_l + 1
      )
    )
  )
}

heatmap_text_layer <- function(..., .op, .df, .label, .num, .color, .threshold, .labeller, .size = 11 / .pt) {
  .df_filt <- .df |> filter(`.op`(.df[[.label]], .threshold))
  if(nrow(.df_filt) == 0) {
    return(list(...))
  }
  list(
    ...,
    geom_text(
      data = .df_filt,
      color = .color,
      size = .size,
      fontface = 'bold',
      aes(
        label = .labeller(.df = .df_filt, .label = .label, .num = .num),
        x = .data$pre_cumu_w + 0.5, 
        y = .data$pre_cumu_l + 0.5
      )
    )
  )
}

heatmap_text_layers <- function(
    ..., 
    .df,
    .threshold,
    .labeller,
    .f
) {
  list(
    ...,
    .f(.df = .df, .threshold = .threshold, .labeller = .labeller, .emphasize = 'low'),
    .f(.df = .df, .threshold = .threshold, .labeller = .labeller, .emphasize = 'high')
  )
}

cod_heatmap_seq_labeller <- function(.df, .label, .num) {
  sprintf(
    '%s\n(%s)',
    scales::percent(.df[[.label]], accuracy = 1), 
    scales::comma(.df$n)
  )
}

o_round_win_text_layer <- function(
    ..., 
    .df,
    .threshold,
    .labeller,
    .label = 'win_round_prop',
    .num = 'win_round',
    .emphasize
) {
  if(.emphasize == 'low') {
    op <- `<`
    .color <- blackish_background
  } else {
    op <- `>=`
    .color <- 'white'
  }
  list(
    ...,
    heatmap_text_layer(
      .df = .df,
      .op = op,
      .label = .label,
      .num = .num,
      .color = .color,
      .threshold = .threshold,
      .labeller = .labeller,
      .size = 11 / .pt
    )
  )
}

cod_heatmap_div_labeller <- function(.df, .label, .num) {
  sprintf(
    '%+.1f\n(%s)', 
    100 * .df[[.label]], 
    scales::comma(.df$n)
  )
}

o_round_win_over_expected_text_layer <- function(
    ..., 
    .df, 
    .threshold,
    .labeller,
    .emphasize
) {
  if(.emphasize == 'low') {
    op <- `<`
    .color <- 'white'
  } else {
    op <- `>=`
    .color <- blackish_background
  }
  list(
    ...,
    heatmap_text_layer(
      .df = .df,
      .op = op,
      .label = 'diff_win_round_prop',
      .num = 1,
      .color = .color,
      .threshold = .threshold,
      .labeller = .labeller
    )
  )
}

extract_ggsci_mid_color <- function(palette) {
  ggsci::pal_material(palette, n = 3)(2)[2]
}

ggsci_purple <- extract_ggsci_mid_color('purple')
ggsci_green <- extract_ggsci_mid_color('green')
ggsci_cyan <- extract_ggsci_mid_color('cyan')
ggsci_brown <- extract_ggsci_mid_color('brown')
```

```{r}
#| label: cod_rounds-calcs
cod_round_and_series_win_prop_by_side <- cod_rounds |> 
  group_by(pre_cumu_w, pre_cumu_l, is_offense) |> 
  summarize(
    n = n(),
    across(c(win_round, win_series), sum)
  ) |> 
  ungroup() |> 
  mutate(
    win_round_prop = win_round / n,
    win_series_prop = win_series / n
  )

cod_e_o_win_series_prop <- crossing(
  pre_cumu_w = 0:5,
  pre_cumu_l = 0:5
) |> 
  mutate(
    n_remain_max = 11 - (pre_cumu_w + pre_cumu_l),
    n_remain_w = 6 - pre_cumu_w,
    ## can i account for offense in this by rotating?
    e_win_series_prop = map2_dbl(n_remain_w, n_remain_max, ~sum(dbinom(..1:..2, ..2, 0.5)))
  )

cod_o_win_prop <- cod_round_and_series_win_prop_by_side |> 
  filter(is_offense) |> 
  mutate(
    diff_win_round_prop = win_round_prop - !!cod_o_win_prop_const
  ) |> 
  inner_join(
    cod_e_o_win_series_prop |> select(pre_cumu_w, pre_cumu_l, e_win_series_prop),
    by = c('pre_cumu_w', 'pre_cumu_l')
  ) |> 
  mutate(
    diff_win_series_prop = win_series_prop - e_win_series_prop
  )
```

```{r}
#| label: p_cod_o_round_win_prop
p_cod_o_round_win_prop <- cod_o_win_prop |> 
  ggplot() +
  common_cod_heatmap_layers() +
  heatmap_tile(.fill = 'win_round_prop') +
  heatmap_text_layers(
    .df = cod_o_win_prop,
    .f = o_round_win_text_layer,
    .threshold = 0.52,
    .labeller = cod_heatmap_seq_labeller
  ) +
  ggsci::scale_fill_material('teal') +
  labs(
    title = 'Offensive Round Win %'
  )
p_cod_o_round_win_prop
save_plot_for_slide(p_cod_o_round_win_prop)
```

![](plots/cod_o_round_win_prop.png){fig-align="center"}

## What are your chances of winning the next round ([COD SnD]{.cod})?

```{r}
#| label: p_cod_o_round_win_prop_over_expected
cod_max_diff_win_round_prop <- max(abs(cod_o_win_prop$diff_win_round_prop))
p_cod_o_round_win_prop_over_expected <- cod_o_win_prop |> 
  ggplot() +
  common_cod_heatmap_layers() +
  heatmap_tile(.fill = 'diff_win_round_prop') +
  heatmap_text_layers(
    .df = cod_o_win_prop, 
    .f = o_round_win_over_expected_text_layer,
    .threshold = -0.1,
    .labeller = cod_heatmap_div_labeller
  ) +
  scale_fill_gradient2(
    low = ggsci_purple,
    high = ggsci_green,
    mid = 'white',
    midpoint = 0,
    limits = c(
      -cod_max_diff_win_round_prop, 
      +cod_max_diff_win_round_prop
    )
  ) +
  labs(
    title = 'Offensive Round Win % Over Expected'
  )
p_cod_o_round_win_prop_over_expected
save_plot_for_slide(p_cod_o_round_win_prop_over_expected)
```

![](plots/cod_o_round_win_prop_over_expected.png){fig-align="center"}

## What are your chances of winning the next round ([Valorant]{.valorant})?

```{r}
#| label: val-funcs
drop_25th_round <- function(df) {
  df |> 
    filter(
      !(pre_cumu_w == 12 & pre_cumu_l == 12)
    )
}

val_e_o_win_series_prop <- crossing(
  pre_cumu_w = 0:12,
  pre_cumu_l = 0:12
) |> 
  drop_25th_round() |> 
  mutate(
    n_remain_max = 25 - (pre_cumu_w + pre_cumu_l),
    n_remain_w = 13 - pre_cumu_w,
    ## can i account for offense in this by rotating?
    e_win_series_prop = map2_dbl(n_remain_w, n_remain_max, ~sum(dbinom(..1:..2, ..2, 0.5)))
  )


## Joshua Broas, vlr.gg
common_val_labs <- function(...) {
  list(
    ...,
    labs(
      caption = '2021 VCT matches'
    )
  )
}

common_val_heatmap_layers <- function(...) {
  list(
    ...,
    guides(
      fill = 'none'
    ),
    scale_x_continuous(
      labels = 0:12,
      breaks = seq(0.5, 12.5, by = 1),
      expand = c(0, 0)
    ),
    scale_y_continuous(
      labels = 0:12,
      breaks = seq(0.5, 12.5, by = 1),
      expand = c(0, 0),
      sec.axis = sec_axis(
        trans = I, 
        name = ' ', 
        breaks = seq(0.5, 12.5, by = 1), 
        labels = rep('', 13)
      )
    ),
    theme(
      panel.grid.major = element_blank(),
      axis.title = element_text(hjust = 0.5),
      plot.title = ggtext::element_markdown(hjust = 0.5),
      axis.text = element_text(size = 16, face = 'bold')
    ),
    common_val_labs(),
    labs(
      x = "Offensive Team's # of Pre-Round Wins",
      y = "Defensive Team's # of Pre-Round Wins"
    )
  )
}

val_heatmap_seq_labeller <- function(.df, .label, .num) {
  sprintf(
    '%s\n(%s)', 
    scales::percent(.df[[.label]], accuracy = 1), 
    scales::comma(.df$n)
  )
}

o_series_win_text_layer <- function(
    ..., 
    .df,
    .threshold,
    .labeller, 
    .emphasize
) {
  if(.emphasize == 'low') {
    op <- `<`
    .color <- blackish_background
  } else {
    op <- `>=`
    .color <- 'white'
  }
  list(
    ...,
    heatmap_text_layer(
      .df = .df,
      .op = op,
      .label = 'win_series_prop',
      .num = 'win_series',
      .color = .color,
      .threshold = .threshold,
      .labeller = .labeller,
      .size = 9 / .pt
    )
  )
}

val_heatmap_div_labeller <- function(.df, .label, .num) {
  sprintf(
    '%+.1f\n(%s)', 
    100 * .df[[.label]], 
    scales::comma(.df$n)
  )
}

o_series_win_over_expected_text_layer <- function(
    ..., 
    .df,
    .threshold,
    .labeller, 
    .emphasize
) {
  if(.emphasize == 'low') {
    op <- `<`
    .color <- blackish_background
  } else {
    op <- `>=`
    .color <- 'white'
  }
  list(
    ...,
    heatmap_text_layer(
      .df = .df,
      .op = op,
      .label = 'diff_win_series_prop',
      .num = NULL,
      .color = .color,
      .threshold = .threshold,
      .labeller = .labeller,
      .size = 9 / .pt
    )
  )
}
```

```{r}
#| label: val_rounds-calcs
val_round_and_series_win_prop_by_side <- val_rounds |> 
  group_by(pre_cumu_w, pre_cumu_l, is_offense) |> 
  summarize(
    n = n(),
    across(c(win_round, win_series), sum)
  ) |> 
  ungroup() |> 
  mutate(
    win_round_prop = win_round / n,
    win_series_prop = win_series / n
  )

val_o_win_prop <- val_round_and_series_win_prop_by_side |> 
  filter(is_offense) |> 
  mutate(
    diff_win_round_prop = win_round_prop - !!val_o_win_prop_const
  ) |> 
  inner_join(
    val_e_o_win_series_prop |> select(pre_cumu_w, pre_cumu_l, e_win_series_prop),
    by = c('pre_cumu_w', 'pre_cumu_l')
  ) |> 
  mutate(
    diff_win_series_prop = win_series_prop - e_win_series_prop
  ) |> 
  filter(pre_cumu_w <= 12, pre_cumu_l <= 12) |> 
  drop_25th_round()
```

```{r}
#| label: val_rounds_bothbuy-calcs
val_bothbuy_rounds <- val_rounds |> 
  filter(
    team_buy_type %in% c('semi-buy', 'full-buy'), 
    opponent_buy_type  %in% c('semi-buy', 'full-buy')
  )

val_bothbuy_o_win_prop_const <- val_bothbuy_rounds |> 
  filter(is_offense) |> 
  count(win_round) |> 
  mutate(prop = n / sum(n)) |> 
  filter(win_round) |> 
  pull(prop)

val_round_and_series_win_prop_by_side_bothbuy <- val_bothbuy_rounds |> 
  group_by(pre_cumu_w, pre_cumu_l, is_offense) |> 
  summarize(
    n = n(),
    across(c(win_round, win_series), sum)
  ) |> 
  ungroup() |> 
  mutate(
    win_round_prop = win_round / n,
    win_series_prop = win_series / n
  )

val_o_win_prop_bothbuy <- val_round_and_series_win_prop_by_side_bothbuy |> 
  filter(is_offense) |> 
  mutate(
    diff_win_round_prop = win_round_prop - !!val_bothbuy_o_win_prop_const
  ) |> 
  inner_join(
    val_e_o_win_series_prop |> select(pre_cumu_w, pre_cumu_l, e_win_series_prop),
    by = c('pre_cumu_w', 'pre_cumu_l')
  ) |> 
  mutate(
    diff_win_series_prop = win_series_prop - e_win_series_prop
  ) |> 
  filter(pre_cumu_w <= 12, pre_cumu_l <= 12) |> 
  drop_25th_round()
```

```{r}
#| label: val-funcs-2
val_pre_swap_rounds <- val_o_win_prop |> 
  mutate(pre_cumu_wl = pre_cumu_w + pre_cumu_l) |> 
  filter(pre_cumu_wl == 12)

val_pre_swap_round_segments <- val_pre_swap_rounds |> 
  transmute(
    pre_cumu_w,
    across(pre_cumu_l, ~.x),
    i = row_number(),
    n = 2
  ) |> 
  uncount(n) |> 
  group_by(i) |> 
  mutate(rn = row_number()) |> 
  ungroup() |> 
  mutate(
    across(pre_cumu_w, ~ifelse(rn == 2, .x + 1, .x))
  ) |> 
  add_row(
    pre_cumu_w = 12,
    pre_cumu_l = 0
  )

val_swap_path <- function(...) {
  list(
    ...,
    geom_path(
      data = val_pre_swap_round_segments,
      color = 'white',
      size = 1.5,
      aes(
        x = pre_cumu_w, 
        y = pre_cumu_l
      )
    )
  )
}
```

```{r}
#| label: p_val_o_round_win_prop
p_val_o_round_win_prop <- val_o_win_prop |> 
  ggplot() +
  common_val_heatmap_layers() +
  heatmap_tile(.fill = 'win_round_prop') +
  val_swap_path() +
  heatmap_text_layers(
    .df = val_o_win_prop, 
    .f = o_round_win_text_layer,
    .threshold = 0.8,
    .labeller = val_heatmap_seq_labeller
  ) +
  ggsci::scale_fill_material('teal') +
  labs(
    title = 'Offensive Round Win %'
  )
p_val_o_round_win_prop
save_plot_for_slide(p_val_o_round_win_prop)

p_val_o_round_win_prop_bothbuy <- val_o_win_prop_bothbuy |> 
  ggplot() +
  common_val_heatmap_layers() +
  heatmap_tile(.fill = 'win_round_prop') +
  val_swap_path() +
  heatmap_text_layers(
    .df = val_o_win_prop_bothbuy, 
    .f = o_round_win_text_layer,
    .threshold = 0.8,
    .labeller = val_heatmap_seq_labeller
  ) +
  ggsci::scale_fill_material('teal') +
  labs(
    title = 'Offensive Round Win %'
  )
p_val_o_round_win_prop_bothbuy
save_plot_for_slide(p_val_o_round_win_prop_bothbuy)
```

![](plots/val_o_round_win_prop.png){fig-align="center"}

## What are your chances of winning the series ([COD SnD]{.cod})?

```{r}
#| label: p_cod_o_series_win_prop
p_cod_o_series_win_prop <- cod_o_win_prop |> 
  ggplot() +
  common_cod_heatmap_layers() +
  heatmap_tile(.fill = 'win_series_prop') +
  heatmap_text_layers(
    .df = cod_o_win_prop, 
    .f = o_series_win_text_layer,
    .threshold = 0.8,
    .labeller = cod_heatmap_seq_labeller
  ) +
  ggsci::scale_fill_material('orange') +
  labs(
    title = 'Offensive Series Win %'
  )
p_cod_o_series_win_prop
save_plot_for_slide(p_cod_o_series_win_prop)
```

![](plots/cod_o_series_win_prop.png){fig-align="center"}

## What are your chances of winning the series ([COD SnD]{.cod})?

```{r}
#| label: p_cod_o_series_win_prop_over_expected
cod_max_diff_win_series_prop <- max(abs(cod_o_win_prop$diff_win_series_prop))
p_cod_o_series_win_prop_over_expected <- cod_o_win_prop |> 
  ggplot() +
  common_cod_heatmap_layers() +
  heatmap_tile(
    .fill = 'diff_win_series_prop'
  ) +
  heatmap_text_layers(
    .df = cod_o_win_prop, 
    .f = o_series_win_over_expected_text_layer,
    .threshold = 0.08,
    .labeller = cod_heatmap_div_labeller
  ) +
  scale_fill_gradient2(
    low = ggsci_brown,
    high = ggsci_cyan,
    mid = 'white',
    midpoint = 0,
    limits = c(
      -cod_max_diff_win_series_prop, 
      +cod_max_diff_win_series_prop
    )
  ) +
  labs(
    title = 'Offensive Series Win % Over Expected'
  )
p_cod_o_series_win_prop_over_expected
save_plot_for_slide(p_cod_o_series_win_prop_over_expected)
```

![](plots/cod_o_series_win_prop_over_expected.png){fig-align="center"}

## What are your chances of winning the series ([Valorant]{.valorant})?

```{r}
#| label: p_val_o_series_win_prop
p_val_o_series_win_prop <- val_o_win_prop |> 
  ggplot() +
  common_val_heatmap_layers() +
  heatmap_tile(.fill = 'win_series_prop') +
  val_swap_path() +
  heatmap_text_layers(
    .df = val_o_win_prop, 
    .f = o_series_win_text_layer,
    .threshold = 0.8,
    .labeller = val_heatmap_seq_labeller
  ) +
  ggsci::scale_fill_material('orange') +
  labs(
    title = 'Offensive Series Win %'
  )
p_val_o_series_win_prop
save_plot_for_slide(p_val_o_series_win_prop)
```

![](plots/val_o_series_win_prop.png){fig-align="center"}

## What are your chances of winning the series ([Valorant]{.valorant})?

```{r}
#| label: p_val_o_series_win_prop_over_expected
val_max_diff_win_series_prop <- max(abs(val_o_win_prop$diff_win_series_prop))
p_val_o_series_win_prop_over_expected <- val_o_win_prop |> 
  ggplot() +
  common_val_heatmap_layers() +
  heatmap_tile(
    .fill = 'diff_win_series_prop'
  ) +
  heatmap_text_layers(
    .df = val_o_win_prop, 
    .f = o_series_win_over_expected_text_layer,
    .threshold = 0.2,
    .labeller = val_heatmap_div_labeller
  ) +
  val_swap_path() +
  scale_fill_gradient2(
    low = ggsci_brown,
    high = ggsci_cyan,
    mid = 'white',
    limits = c(
      -val_max_diff_win_series_prop,
      +val_max_diff_win_series_prop
    ),
    midpoint = 0
  ) +
  labs(
    title = 'Offensive Series Win % Over Expected'
  )
p_val_o_series_win_prop_over_expected
save_plot_for_slide(p_val_o_series_win_prop_over_expected)
```

![](plots/val_o_series_win_prop_over_expected.png){fig-align="center"}

## What are your chances of winning the series ([Valorant]{.valorant})?

```{r}
#| label: p_filt_val_o_series_win_prop_over_expected
filt_val_o_win_prop <- val_o_win_prop |> 
  mutate(
    across(
      diff_win_series_prop,
      ~case_when(
        pre_cumu_w <= 3 & pre_cumu_l <= 3 ~ NA_real_,
        TRUE ~ .x
      )
    )
  )
filt_val_max_diff_win_series_prop <- max(abs(filt_val_o_win_prop$diff_win_series_prop))

p_filt_val_o_series_win_prop_over_expected <- filt_val_o_win_prop |> 
  ggplot() +
  common_val_heatmap_layers() +
  heatmap_tile(
    .fill = 'diff_win_series_prop'
  ) +
  heatmap_text_layers(
    .df = filt_val_o_win_prop, 
    .f = o_series_win_over_expected_text_layer,
    .threshold = 0.1,
    .labeller = val_heatmap_div_labeller
  ) +
  val_swap_path() +
  scale_fill_gradient2(
    low = ggsci_brown,
    high = ggsci_cyan,
    mid = 'white',
    limits = c(
      -filt_val_max_diff_win_series_prop,
      +filt_val_max_diff_win_series_prop
    ),
    midpoint = 0
  ) +
  labs(
    title = 'Offensive Series Win % Over Expected'
  )
p_filt_val_o_series_win_prop_over_expected
save_plot_for_slide(p_filt_val_o_series_win_prop_over_expected)
```

![](plots/filt_val_o_series_win_prop_over_expected.png){fig-align="center"}

## Are offensive win %'s different in round 1 ([COD SnD]{.cod})?

```{r}
#| label: p_cod_o_win_r1_vs_post_round_prop
# https://raw.githubusercontent.com/dgrtwo/splittestr/master/R/vectorized-prop-test.R
vectorized_prop_test_approx <- function(a, b, c, d) {
  n1 <- a + b
  n2 <- c + d
  n <- n1 + n2
  p <- (a + c) / n
  E <- cbind(p * n1, (1 - p) * n1, p * n2, (1 - p) * n2)
  
  x <- cbind(a, b, c, d)
  
  DELTA <- a / n1 - c / n2
  YATES <- pmin(.5, abs(DELTA) / sum(1 / n1 + 1 / n2))
  
  STATISTIC <- rowSums((abs(x - E) - YATES)^2 / E)
  PVAL <- pchisq(STATISTIC, 1, lower.tail = FALSE)
  PVAL
}

vectorized_prop_test_exact <- function(a, b, c, d) {
  sapply(seq_along(a), function(i) {
    fisher.test(cbind(c(a[i], c[i]), c(b[i], d[i])))$p.value
  })
}

vectorized_prop_test <- function(x1, n1, x2, n2, conf.level = .95) {
  a <- x1
  b <- n1 - x1
  c <- x2
  d <- n2 - x2
  
  # if any values are < 20, use Fisher's exact test
  exact <- (a < 20 | b < 20 | c < 20 | d < 20)
  
  pvalue <- rep(NA, length(a))
  
  if (any(exact)) {
    pvalue[exact] <- vectorized_prop_test_exact(a[exact], b[exact], c[exact], d[exact])
  }
  if (any(!exact)) {
    pvalue[!exact] <- vectorized_prop_test_approx(a[!exact], b[!exact], c[!exact], d[!exact])
  }
  
  mu1 <- a / (a + b)
  mu2 <- c / (c + d)
  
  ## confidence interval
  alpha2 <- (1 - conf.level) / 2
  DELTA <- mu2 - mu1
  WIDTH <- qnorm(alpha2)
  alpha <- (a + .5) / (a + b + 1)
  beta <- (c + .5) / (c + d + 1)
  
  n <- n1 + n2
  YATES <- pmin(.5, abs(DELTA) / sum(1 / n1 + 1 / n2))
  
  z <- qnorm((1 + conf.level) / 2)
  WIDTH <- z * sqrt(mu1 * (1 - mu1) / n1 + mu2 * (1 - mu2) / n2)
  
  tibble(
    estimate = DELTA,
    conf.low = pmax(DELTA - WIDTH, -1),
    conf.high = pmin(DELTA + WIDTH, 1),
    p.value = pvalue
  )
}

calculate_map_o_round_win_prop <- function(df) {
  df |> 
    count(map, is_offense, win_round) |> 
    group_by(map, is_offense) |> 
    mutate(total = sum(n), prop = n / total) |> 
    ungroup() |>
    filter(win_round, is_offense) |>
    select(
      map,
      rounds_won = n,
      total_rounds = total,
      win_round_prop = prop
    ) |>
    arrange(desc(win_round_prop))
}

summarize_map_o_round_win_prop <- function(df, .round) {
  
  specified_round <- df |> 
    filter(round == .round) |> 
    calculate_map_o_round_win_prop()
  
  post_rounds <- df |> 
    filter(round > .round) |> 
    calculate_map_o_round_win_prop()
  
  specified_round |> 
    inner_join(
      post_rounds |> rename_with(~sprintf('post_%s', .x), -c(map)),
      by = 'map'
    ) |> 
    mutate(round = .round, .after = 'map') |> 
    arrange(desc(win_round_prop)) |> 
    mutate(
      prop_test = vectorized_prop_test(rounds_won, total_rounds, post_rounds_won, post_total_rounds),
      p_value = prop_test$p.value
    ) |> 
    arrange(p_value) |> 
    mutate(
      diff_prop = post_win_round_prop - win_round_prop,
      dir = factor(sign(diff_prop)),
      is_significant = p_value < 0.05
    )
}

o_win_rx_prop_pal <- c(
  `-1` = extract_ggsci_mid_color('pink'),
  `1` = extract_ggsci_mid_color('teal')
)

arw <- arrow(length = unit(5, 'pt'), type = 'closed')

plot_round_vs_post_round_slope_chart <- function(df, .round, game = c('cod', 'val')) {
  game <- match.arg(game)
  o_win_rx_prop <- summarize_map_o_round_win_prop(df, .round)
  x1_label <- sprintf('Round %d<br/>offensive win %%', .round)
  x2_label <- sprintf('Post-round %d<br/>offensive win %%', .round)
  
  min_o_win_rx_prop <- o_win_rx_prop |> slice_min(diff_prop, n = 1)
  max_o_win_rx_prop <- o_win_rx_prop |> slice_max(diff_prop, n = 1)
  minmax_maps <- c(min_o_win_rx_prop$map, max_o_win_rx_prop$map)
  
  is_cod <- game == 'cod'
  if (is_cod) {
    y_lo <- 0.25
    y_hi <- 0.75
  } else {
    y_lo <- 0.45
    y_hi <- 0.55
  }
  
  p <- o_win_rx_prop |> 
    ggplot() +
    geom_vline(
      data = tibble(),
      aes(xintercept = c(1, 2)), 
      color = gray_points
    ) +
    geom_hline(
      data = tibble(),
      aes(yintercept = c(y_lo, 0.5, y_hi)), 
      linetype = 2,
      color = gray_points
    ) +
    geom_segment(
      data = o_win_rx_prop |> 
        mutate(
          big_segment = map %in% minmax_maps
        ),
      show.legend = FALSE,
      aes(
        x = 1,
        xend = 2,
        y = win_round_prop,
        yend = post_win_round_prop,
        color = dir,
        size = big_segment,
        group = map
      )
    ) +
    geom_text(
      data = tibble(
        y = c(y_lo, y_hi)
      ) |> 
        mutate(
          lab = sprintf('%s%%', round(100 * y))
        ),
      aes(x = 2, y = y, label = lab), 
      size = 12 / .pt,
      hjust = -0.05,
      vjust = -0.25,
      fontface = 'bold',
      color = 'white'
    ) +
    ggtext::geom_richtext(
      fill = blackish_background, 
      label.color = NA,
      data = tibble(
        x = c(1, 2),
        y = rep(0.7, 2),
        lab = c(x1_label, x2_label)
      ),
      aes(x = x, y = y, label = lab), 
      size = 9 / .pt,
      hjust = 0.5,
      vjust = 0.5,
      family = font,
      fontface = 'bold',
      color = 'white'
    ) +
    ggrepel::geom_text_repel(
      data = o_win_rx_prop |> 
        filter(map %in% !!minmax_maps),
      aes(x = 1, y = win_round_prop, label = map),
      family = font,
      fontface = 'bold',
      color = 'white',
      size = 9 / .pt,
      hjust = 'right', 
      nudge_x = -0.1,
      direction = 'y'
    ) +
    ggrepel::geom_text_repel(
      data = o_win_rx_prop |> 
        filter(!(map %in% !!minmax_maps)),
      aes(x = 2, y = post_win_round_prop, label = map),
      family = font,
      color = gray_text,
      size = 9 / .pt,
      hjust = 'left', 
      nudge_x = 0.1,
      direction = 'y'
    ) +
    scale_x_continuous(
      position = 'top',
      breaks = c(1, 2),
      expand = expansion(mult = 0.5)
    ) +
    scale_y_continuous(
      limits = c(y_lo, y_hi)
    ) +
    scale_size_manual(
      values = c(
        `FALSE` = 0.5,
        `TRUE` = 2
      )
    ) +
    scale_color_manual(
      name = NULL,
      values = o_win_rx_prop_pal
    ) +
    theme(
      plot.title = element_text(hjust = 0.5),
      panel.grid.major = element_blank(),
      axis.text.x = element_blank(),
      axis.text.y = element_blank()
    ) +
    labs(
      x = NULL,
      y = NULL
    )
  list(
    plot = p,
    data = o_win_rx_prop,
    largest_neg_diff_prop = min_o_win_rx_prop$diff_prop,
    largest_pos_diff_prop = max_o_win_rx_prop$diff_prop
  )
}

cod_res_r1 <- cod_rounds |> 
  plot_round_vs_post_round_slope_chart(1, game = 'cod')

p_cod_o_win_r1_vs_post_round_prop <- cod_res_r1$plot +
  geom_curve(
    data = tibble(),
    aes(x = 1.2, y = 0.65, xend = 1.1, yend = 0.63),
    curvature = 0.2, 
    color = o_win_rx_prop_pal[["-1"]], 
    arrow = arw
  ) +
  geom_curve(
    data = tibble(),
    aes(x = 1.24, y = 0.27, xend = 1.1, yend = 0.27),
    curvature = 0-.2, 
    color = o_win_rx_prop_pal[["1"]], 
    arrow = arw
  ) +
  geom_text(
    data = tibble(
      x = c(1.2, 1.24),
      y = c(0.65, 0.27),
      hjust = c(0, 0),
      vjust = c(0.5, 0.5),
      lab = c(
        sprintf(
          'Largest negative percent difference in round 1\nvs. all other round win percentages (%+.0f%%).', 
          100 * cod_res_r1$largest_neg_diff_prop
        ),
        sprintf(
          'Largest positive percent difference (%+.0f%%).\nOnly significant difference (p value < 0.01).',
          100 * cod_res_r1$largest_pos_diff_prop
        )
      )
    ),
    color = 'white',
    size = 9 / .pt,
    aes(x = x, y = y, hjust = hjust, vjust = vjust, label = lab)
  ) +
  common_cod_labs()
p_cod_o_win_r1_vs_post_round_prop
save_plot_for_slide(p_cod_o_win_r1_vs_post_round_prop)
```

![](plots/cod_o_win_r1_vs_post_round_prop.png){fig-align="center"}

## Are offensive win %'s different in round 1 ([Valorant]{.valorant})?

```{r}
#| label: p_val_o_win_r1_vs_post_round_prop
p_val_o_win_r1_vs_post_round_prop <- val_rounds |> 
  plot_round_vs_post_round_slope_chart(1, game = 'val') |> 
  pluck('plot') +
  common_val_labs()
save_plot_for_slide(p_val_o_win_r1_vs_post_round_prop)
```

![](plots/val_o_win_r1_vs_post_round_prop.png){fig-align="center"}

## What are the most common series winning states ([COD SnD]{.cod})?

```{r}
#| label: p_cod_series_outcome_prop_over_expected
# https://content.iospress.com/articles/journal-of-sports-analytics/jsa200422
prob_of_series_lasting_n_games <- function(n, p = 0.5, max_round) {
  s <- ceiling(max_round / 2)
  (factorial(n - 1) / (factorial(s - 1) * factorial(n - s))) * (p^s * (1 - p)^(n - s) + p^(n - s) * (1 - p)^s)
}

expected_series_streaks_of_outcomes <- function(m, n) {
  factorial(m + n) / (factorial(m) * factorial(n))
}

summarize_streaks <- function(rounds, game = c('cod', 'val')) {
  if (game == 'cod') {
    .max_round <- 11
    .adj <- 0
  } else {
    .max_round <- 25
    .adj <- 1
  }
  
  cutoff <- (.max_round + 1) / 2
  
  actual_round_streaks <- rounds |> 
    filter(round <= (.max_round - .adj)) |> 
    filter(win_series) |> 
    mutate(across(win_round, as.integer)) |> 
    group_by(series_id) |> 
    summarize(
      wins = max(cumu_w),
      losses = max(cumu_l),
      ws = paste0(win_round, collapse = '')
    ) |> 
    ungroup() |> 
    mutate(n_rounds = wins + losses) |> 
    unite(
      record, wins, losses, sep = '-'
    ) |>
    count(record, n_rounds, ws, sort = TRUE) |> 
    mutate(prop = n / sum(n))
  
  expected_round_streaks <- tibble(
    n_rounds = cutoff:.max_round
  ) |> 
    mutate(
      series_prop = map_dbl(n_rounds, ~prob_of_series_lasting_n_games(.x, max_round = .max_round)),
      n_expected_series_streaks = map2_dbl(cutoff, n_rounds - cutoff, expected_series_streaks_of_outcomes)
    ) |> 
    transmute(
      n_rounds,
      series_prop,
      prop = series_prop / n_expected_series_streaks
    )
  
  round_streaks <- full_join(
    actual_round_streaks |> 
      rename_with(~sprintf('%s_actual', .x), c(n, prop)),
    expected_round_streaks |> 
      rename_with(~sprintf('%s_expected', .x), prop),
    by = 'n_rounds'
  )
  
  round_streak_prop <- round_streaks |> 
    drop_na() |> 
    mutate(
      prop_diff = prop_actual - prop_expected,
      total_actual = sum(n_actual),
      n_expected = round(prop_expected * total_actual),
      p = vectorized_prop_test(n_actual, total_actual, n_expected, total_actual)
    ) |> 
    select(-total_actual) |> 
    unnest_wider(p) |> 
    arrange(p.value)
  
  series_outcomes <- full_join(
    actual_round_streaks |> 
      group_by(record, n_rounds) |> 
      summarize(
        across(n, sum)
      ) |> 
      ungroup() |> 
      mutate(prop = n / sum(n)) |> 
      rename_with(~sprintf('%s_actual', .x), c(n, prop)),
    expected_round_streaks |> 
      select(n_rounds, prop_expected = series_prop),
    by = 'n_rounds'
  )
  
  series_outcome_prop <- series_outcomes |> 
    drop_na() |> 
    mutate(
      prop_diff = prop_actual - prop_expected,
      total_actual = sum(n_actual),
      n_expected = round(prop_expected * total_actual),
      p = vectorized_prop_test(n_actual, total_actual, n_expected, total_actual)
    ) |> 
    select(-total_actual) |> 
    unnest_wider(p) |> 
    arrange(p.value)
  
  list(
    rounds = round_streak_prop,
    series = series_outcome_prop
  )
}

plot_series_outcome_prop_over_expected <- function(series_outcome_prop, game) {
  if (game == 'cod') {
    .lvls <- sprintf('6-%d', 0:5)
    .axis_x_text_size <- 14
  } else {
    .lvls <- c(sprintf('13-%d', 0:11), '12-12')
    .axis_x_text_size <- 12
  }
  
  long_series_outcome_prop <- series_outcome_prop |>
    select(
      record,
      n = n_actual,
      `3` = prop_actual,
      `2` = prop_expected,
      `1` = prop_diff
    ) |> 
    pivot_longer(
      matches('[123]'),
      names_to = 'outcome_idx',
      values_to = 'value'
    ) |> 
    mutate(
      across(outcome_idx, as.integer),
      across(record, ~factor(.x, levels = .lvls))
    )
  
  max_diff_series_outcome_prop <- long_series_outcome_prop |> 
    filter(outcome_idx == 1) |> 
    pull(value) |> 
    abs() |> 
    max()
  
  long_series_outcome_prop |> 
    ggplot() +
    aes(x = record, y = outcome_idx) +
    geom_tile(
      data = long_series_outcome_prop |> filter(outcome_idx > 1),
      show.legend = FALSE,
      # height = 0.8,
      aes(fill = value)
    ) +
    ggsci::scale_fill_material(
      palette = 'light-blue'
    ) +
    ggnewscale::new_scale_fill() +
    geom_tile(
      data = long_series_outcome_prop |> filter(outcome_idx == 1),
      show.legend = FALSE,
      height = 0.8,
      aes(fill = value)
    ) +
    scale_fill_gradient2(
      low = extract_ggsci_mid_color('purple'),
      high = extract_ggsci_mid_color('green'),
      mid = 'white',
      midpoint = 0,
      limits = c(
        -max_diff_series_outcome_prop, 
        +max_diff_series_outcome_prop
      )
    ) +
    geom_text(
      data = long_series_outcome_prop |> filter(outcome_idx == 3),
      color = blackish_background,
      size = 11 / .pt,
      aes(label = sprintf('%.1f%%\n(%s)', 100 * value, scales::comma(n)))
    ) +
    geom_text(
      data = long_series_outcome_prop |> filter(outcome_idx == 2),
      color = blackish_background,
      size = 11 / .pt,
      aes(label = sprintf('%.1f%%', 100 * value))
    ) +
    geom_text(
      data = long_series_outcome_prop |> filter(outcome_idx == 1) |> filter(abs(value) != max(abs(value))),
      color = blackish_background,
      size = 11 / .pt,
      aes(label = sprintf('%+.1f%%', 100 * value))
    ) +
    geom_text(
      data = long_series_outcome_prop |> filter(outcome_idx == 1) |> filter(abs(value) == max(abs(value))),
      color = 'white',
      size = 11 / .pt,
      aes(label = sprintf('%+.1f%%', 100 * value))
    ) +
    scale_x_discrete(
      position = 'top',
      expand = c(0, 0)
    ) +
    scale_y_continuous(
      labels = c('Diff.', 'Expected', 'Actual'),
      breaks = 1:3,
      expand = c(0, 0)
    ) +
    theme(
      panel.grid.major = element_blank(),
      axis.title = element_text(hjust = 0.5),
      plot.title = ggtext::element_markdown(hjust = 0.5),
      axis.text = element_text(size = 14, face = 'bold'),
      axis.text.x = element_text(size = .axis_x_text_size, face = 'bold')
    ) +
    labs(
      title = 'Series outcome %',
      x = NULL,
      y = NULL
    )
}

cod_streaks_res <- cod_rounds |> summarize_streaks('cod')

p_cod_series_outcome_prop_over_expected <- cod_streaks_res$series |> 
  plot_series_outcome_prop_over_expected('cod') +
  common_cod_labs()
p_cod_series_outcome_prop_over_expected
save_plot_for_slide(p_cod_series_outcome_prop_over_expected)
```

![](plots/cod_series_outcome_prop_over_expected.png){fig-align="center"}

## Should round win percentage in [COD SnD]{.cod} be modeled as constant?

::: fragment
[Chance (2019)](https://content.iospress.com/articles/journal-of-sports-analytics/jsa200422) finds that the probability of winning a game in the title series in the MLB and NHL is **not** constant (at 50%)
:::

```{r}
#| label: chance-2019
chance_2019_leagues <- c('MLB World Series', 'NBA Finals', 'NHL Stanley Cup')

n_sports <- tibble(
  league = chance_2019_leagues,
  ## i think nba has to be 2019 instead of 2018 in order for the product of `n * prop_actual` to be a whole number
  n = c(2018 - 1923, 2019 - 1951, 2018 - 1939)
)

chance_sports <- tibble(
  league = rep(chance_2019_leagues, each = 4),
  games = rep(4:7, 3),
  prop_actual = c(
    c(0.1895, 0.2105, 0.2105, 0.3895),
    c(0.1324, 0.25, 0.3382, 0.2794),
    c(0.2532, 0.2278, 0.3165, 0.2025)
  ),
  prop_expected = rep(c(0.125, 0.25, 0.3125, 0.3125), 3)
)

sports <- chance_sports |> 
  inner_join(
    n_sports,
    by = 'league'
  ) |> 
  mutate(
    n_actual = round(n * prop_actual)
  )

generate_chi_label <- function(statistic, p.value) {
  sprintf('%.1f (%s)', statistic, ifelse(p.value <= 0.01, '<=0.01', as.character(round(p.value, 2))))
}

chi_sports <- sports |> 
  nest(data = -c(league)) |> 
  mutate(
    chi = map(data, ~chisq.test(.x$n_actual, p = .x$prop_expected) |> broom::tidy())
  ) |> 
  select(league, chi) |> 
  unnest(chi) |> 
  transmute(
    league, 
    label = generate_chi_label(statistic, p.value)
  )

sports |> 
  select(league, games, prop_expected, prop_actual) |> 
  mutate(
    across(
      starts_with('prop_'),
      scales::percent
    ),
    across(games, as.character)
  ) |> 
  pivot_wider(names_from = league, values_from = prop_actual) |> 
  bind_rows(
    bind_cols(
      tibble(games = 'Avg. # of games'),
      sports |> 
        distinct(games, prop_expected) |>
        summarize(prop_expected = as.character(round(sum(games * prop_expected), 2))),
      sports |> 
        group_by(league) |>
        summarize(z = as.character(round(sum(games * prop_actual), 2))) |> 
        pivot_wider(names_from = league, values_from = z)
    )
  ) |> 
  bind_rows(
    chi_sports |> 
      pivot_wider(names_from = league, values_from = label) |> 
      mutate(
        games = '$\\xi^2$ (p-value)'
      )
  ) |> 
  relocate(
    `Series ends in i games` = games,
    `Expected` = prop_expected
  ) |> 
  knitr::kable()
```

::: fragment
|         Series length | Expected | MLB World Series | NBA Finals | NHL Stanley Cup |
|----------------------:|---------:|-----------------:|-----------:|----------------:|
|                     4 |   12.50% |           18.95% |     13.24% |          25.32% |
|                     5 |   25.00% |           21.05% |     25.00% |          22.78% |
|                     6 |   31.25% |           21.05% |     33.82% |          31.65% |
|                     7 |   31.25% |           38.95% |     27.94% |          20.25% |
|                       |          |                  |            |                 |
|  **Avg. \# of games** |     5.81 |              5.8 |       5.76 |            5.47 |
| $\xi^2$ **(p-value)** |          |       8.7 (0.03) | 0.4 (0.94) |  13.6 (\<=0.01) |
:::

```{r}
#| label: cod_series_outcomes_chi

cod_rounds_per_series <- cod_streaks_res$series |>
  summarize(
    actual = sum(n_rounds * prop_actual),
    expected = sum(n_rounds * prop_expected)
  )
avg_actual_cod_rounds_per_series <- round(cod_rounds_per_series$actual, 2)
avg_expected_cod_rounds_per_series <- round(cod_rounds_per_series$expected, 2)

cod_series_outcomes_chi <- chisq.test(
  cod_streaks_res$series$n_actual, 
  p = cod_streaks_res$series$prop_expected
) |> 
  broom::tidy() |> 
  mutate(label = generate_chi_label(statistic, p.value)) |> 
  pull(label)
cod_series_outcomes_chi
```

```{r}
#| label: cod_series_outcomes_chi-eval
#| eval: true
avg_actual_cod_rounds_per_series <- 9.15
avg_expected_cod_rounds_per_series <- 9.29
cod_series_outcomes_chi <- '15.4 (<=0.01)'
```

::: fragment
-   In COD, the average number of rounds (**`r avg_actual_cod_rounds_per_series`**) is less than the expected value (**`r avg_expected_cod_rounds_per_series`**)
:::

::: fragment
-   A $\xi^2$ test for CoD demonstrates evidence against the constant probability null hypothesis for winning a given round in an SnD series (**`r cod_series_outcomes_chi`**)
:::

## Should round win percentage in [COD SnD]{.cod} be modeled as constant?

```{r}
#| label: alternative-to-p=0.5-method-1
## p. 365 on https://math.mit.edu/classes/18.095/2016IAP/lec9/Sports_Mosteller1952_WorldSeries.pdf
theoretical_cod_series_length <- function(p) {
  6 * prob_of_series_lasting_n_games(n = 6, p = p, max_round = 11) +
    7 * prob_of_series_lasting_n_games(n = 7, p = p, max_round = 11) + 
    8 * prob_of_series_lasting_n_games(n = 8, p = p, max_round = 11) + 
    9 * prob_of_series_lasting_n_games(n = 9, p = p, max_round = 11) +
    10 * prob_of_series_lasting_n_games(n = 10, p = p, max_round = 11) +
    11 * prob_of_series_lasting_n_games(n = 11, p = p, max_round = 11)
}

cod_ps <- tibble(p = seq(0.5, 0.7, by = 0.0025))

cod_theoretical_series_lengths1 <- cod_ps |> 
  mutate(
    theoretical_series_length = map_dbl(p, theoretical_cod_series_length),
    diff = theoretical_series_length - cod_rounds_per_series$actual
  )


cod_theoretical_constant_p1 <- cod_theoretical_series_lengths1 |> 
  slice_min(abs(diff), n = 1) |> 
  pull(p)

pretty_cod_theoretical_constant_p1 <- cod_theoretical_constant_p1 |> 
  scales::percent(accuracy = 0.01)
```

```{r}
#| label: alternative-to-p=0.5-method-1-eval
#| eval: true
pretty_cod_theoretical_constant_p1 <- '57.25%'
```

```{r}
#| label: cod-alternative-to-p=0.5-method-2
pluck_cod_n <- function(.n_rounds) {
  cod_streaks_res$series |>
    filter(n_rounds == .n_rounds) |> 
    pull(n_actual)
}

cod_n6 <- pluck_cod_n(6)
cod_n7 <- pluck_cod_n(7)
cod_n8 <- pluck_cod_n(8)
cod_n9 <- pluck_cod_n(9)
cod_n10 <- pluck_cod_n(10)
cod_n11 <- pluck_cod_n(11)

## This adjustment is something that is not done in the paper. I do it here to reduce
##   the magnitude of the exponents.
cod_pm <- pmin(cod_n6, cod_n7, cod_n8, cod_n9, cod_n10, cod_n11)
cod_n6adj <- round(10 * cod_n6 / cod_pm)
cod_n7adj <- round(10 * cod_n7 / cod_pm)
cod_n8adj <- round(10 * cod_n8 / cod_)
cod_n9adj <- round(10 * cod_n9 / cod_pm)
cod_n10adj <- round(10 * cod_n10 / cod_pm)
cod_n11adj <- round(10 * cod_n11 / cod_pm)

maximize_cod_series_p <- function(p) {
  prob_of_series_lasting_n_games(n = 6, p = p, max_round = 11)^cod_n6adj *
    prob_of_series_lasting_n_games(n = 7, p = p, max_round = 11)^cod_n7adj * 
    prob_of_series_lasting_n_games(n = 8, p = p, max_round = 11)^cod_n8adj * 
    prob_of_series_lasting_n_games(n = 9, p = p, max_round = 11)^cod_n9adj *
    prob_of_series_lasting_n_games(n = 10, p = p, max_round = 11)^cod_n10adj * 
    prob_of_series_lasting_n_games(n = 11, p = p, max_round = 11)^cod_n11adj
}

cod_theoretical_series_lengths2 <- cod_ps |> 
  mutate(
    theoretical_series_length = map_dbl(p, maximize_cod_series_p)
  )

cod_theoretical_constant_p2 <- cod_theoretical_series_lengths2 |> 
  slice_max(theoretical_series_length, n = 1) |> 
  pull(p)

pretty_cod_theoretical_constant_p2 <- cod_theoretical_constant_p2 |> 
  scales::percent(accuracy = 0.01)

best_cod_theoretical_series_lengths2 <- cod_theoretical_series_lengths2 |> 
  filter(p == cod_theoretical_constant_p2)

p_cod_theoretical_series_lengths2 <- cod_theoretical_series_lengths2 |> 
  ggplot() +
  aes(x = p, y = theoretical_series_length) +
  geom_line(
    size = 2,
    color = 'white'
  ) +
  geom_point(
    data = best_cod_theoretical_series_lengths2,
    color = ggsci_cyan,
    size = 6
  ) +
  geom_text(
    data = best_cod_theoretical_series_lengths2,
    color = ggsci_cyan,
    size = 13 / .pt,
    hjust = 0,
    aes(
      x = p + 0.02,
      label = sprintf('Maximum likilihood estimate (MLE) of\nconstant probability of better team winning (%s)', !!pretty_cod_theoretical_constant_p2)
    )
  ) +
  scale_x_continuous(labels = scales::percent) +
  labs(
    x = 'Constant probability of better team winning',
    y = 'Kernel of the multinomial likelihood'
  ) +
  theme(
    axis.text.y = element_blank(),
    panel.grid.major = element_blank()
  )
p_cod_theoretical_series_lengths2
save_plot_for_slide(p_cod_theoretical_series_lengths2)
```

```{r}
#| label: cod-alternative-to-p=0.5-method-2-eval
#| eval: true
pretty_cod_theoretical_constant_p2 <- '53.25%'
```

::: fragment
[Mosteller (1952)](https://math.mit.edu/classes/18.095/2016IAP/lec9/Sports_Mosteller1952_WorldSeries.pdf) suggests several ways to find the optimal constant probability of the "stronger" team winning each game in a series.
:::

::: fragment
-   Using the method of moments approach (Mosteller's method 1), `r pretty_cod_theoretical_constant_p1`
:::

::: fragment
-   Using the maximum likelihood approach (Mosteller's method 2), `r pretty_cod_theoretical_constant_p2`

![](plots/cod_theoretical_series_lengths2.png){fig-align="center" width="65%"}
:::

## What are the most common series winning states ([Valorant]{.valorant})?

```{r}
#| label: p_val_series_outcome_prop_over_expected
val_streaks_res <- val_rounds |> summarize_streaks('val')

p_val_series_outcome_prop_over_expected <- val_streaks_res$series |> 
  plot_series_outcome_prop_over_expected('val') +
  common_val_labs()
p_val_series_outcome_prop_over_expected
save_plot_for_slide(p_val_series_outcome_prop_over_expected)
```

![](plots/val_series_outcome_prop_over_expected.png)

## When do back-to-back round wins occur ([COD SnD]{.cod})?

```{r}
#| label: p_cod_b2b_round_win_prop
summarize_cod_b2b_round_wins <- function(df, ...) {
  df |> 
    arrange(year, sheet, series, team, round) |> 
    group_by(year, sheet, series, team) |> 
    mutate(
      b2b_round_wins = win_round & lag(win_round)
    ) |> 
    ungroup() |> 
    filter(round > 1L) |> 
    count(..., round, b2b_round_wins) |> 
    group_by(..., round) |> 
    mutate(total = sum(n), prop = n / total) |> 
    ungroup() |> 
    filter(b2b_round_wins) |> 
    select(-b2b_round_wins)
}

## now accounting for number of cod_rounds that end up being played...
## seems like there is interesting behavior in the last round, regardless `n_rounds`
cod_b2b_round_win_prop <- cod_rounds |> 
  filter(n_rounds > 6L) |> 
  summarize_cod_b2b_round_wins(n_rounds) |> 
  group_by(n_rounds) |> 
  mutate(
    z = (n - mean(n)) / sd(n),
    rnk = row_number(desc(n))
  ) |> 
  ungroup()

b2b_round_win_prop_tile_layer <- function(..., .df, .round, .palette, .is_new = TRUE) {
  
  init <- if(!.is_new) {
    list()
  } else {
    ggnewscale::new_scale_fill()
  }
  
  list(
    ...,
    init,
    geom_tile(
      data = .df |> filter(n_rounds == .round),
      color = blackish_background,
      height = 0.8,
      show.legend = FALSE,
      aes(
        fill = z,
        x = round + 0.5, 
        y = n_rounds + 0.5
      )
    ),
    ggsci::scale_fill_material(palette = .palette) 
  )
}

b2b_round_win_prop_text_layer <- function(..., .df, .emphasize) {
  if(.emphasize == 'low') {
    op <- `>`
    .color <- blackish_background
  } else {
    op <- `==`
    .color <- 'white'
  }
  list(
    ...,
    geom_text(
      data = .df |> filter(`op`(rnk, 1)),
      color = .color,
      size = 11 / .pt,
      fontface = 'bold',
      aes(
        label = sprintf('%s\n(%s)', scales::percent(prop, accuracy = 1), scales::comma(n)),
        x = round + 0.5, 
        y = n_rounds + 0.5
      )
    )
  )
}

b2b_round_win_prop_text_layers <- function(..., .df) {
  list(
    ...,
    b2b_round_win_prop_text_layer(.df = .df, .emphasize = 'low'),
    b2b_round_win_prop_text_layer(.df = .df, .emphasize = 'high')
  )
}

cod_b2b_round_win_prop_arws <- tibble(
  x = c(9.3, 9.4, 9.75, 10),
  y = c(8.25, 8.5, 8.75, 8.75),
  xend = c(8.1, 9.1, 9.5, 10.5),
  yend = c(7.5, 8.5, 9, 10),
  curvature = c(-0.2, -0.1, 0.1, 0.2)
) |> 
  mutate(
    rn = row_number()
  )

p_cod_b2b_round_win_prop <- cod_b2b_round_win_prop |> 
  ggplot() +
  b2b_round_win_prop_tile_layer(
    .df = cod_b2b_round_win_prop, 
    .round = 7, 
    .palette = 'pink', 
    .is_new = FALSE
  ) +
  b2b_round_win_prop_tile_layer(
    .df = cod_b2b_round_win_prop, 
    .round = 8, 
    .palette = 'light-blue'
  ) +
  b2b_round_win_prop_tile_layer(
    .df = cod_b2b_round_win_prop, 
    .round = 9, 
    .palette = 'light-green'
  ) +
  b2b_round_win_prop_tile_layer(
    .df = cod_b2b_round_win_prop, 
    .round = 10, 
    .palette = 'amber'
  ) +
  b2b_round_win_prop_tile_layer(
    .df = cod_b2b_round_win_prop, 
    .round = 11, 
    .palette = 'deep-orange'
  ) +
  b2b_round_win_prop_text_layers(.df = cod_b2b_round_win_prop) +
  scale_x_continuous(
    labels = 2:11,
    breaks = seq(2.5, 11.5, by = 1),
    expand = c(0, 0.5)
  ) +
  scale_y_continuous(
    labels = 7:11,
    breaks = seq(7.5, 11.5, by = 1),
    expand = c(0, 0)
  ) +
  theme(
    panel.grid.major = element_blank(),
    axis.title = element_text(hjust = 0.5),
    plot.title = ggtext::element_markdown(hjust = 0.5),
    axis.text = element_text(size = 16, face = 'bold')
  ) +
  common_cod_labs() +
  labs(
    title = 'Back-to-back round win %',
    x = 'Round',
    y = '# of rounds played in series'
  ) + 
  geom_text(
    data = tibble(
      label = 'Back-to-back wins occur most\nfrequently in the last round.',
      x = 9.5,
      y = 8.5
    ),
    size = 9 / .pt,
    fontface = 'bold',
    color = 'white',
    hjust = 0,
    vjust = 0.5,
    aes(x = x, y = y, label = label)
  ) +
  map(
    cod_b2b_round_win_prop_arws |> group_split(rn), 
    function(.x) {
      geom_curve(
        data = data.frame(),
        color = 'white',
        arrow = arw,
        aes(x = .x$x, y = .x$y, xend = .x$xend, yend = .x$yend),
        curvature = .x$curvature
      )
    }
  )
p_cod_b2b_round_win_prop
save_plot_for_slide(p_cod_b2b_round_win_prop)
# ## now accounting for number of cod_rounds that end up being played AND series winners...
# cod_rounds |> 
#   filter(win_series, n_rounds > 6L) |> 
#   summarize_b2b_round_wins(n_rounds)
# 
# ## and the losers...
# cod_rounds |> 
#   filter(!win_series) |> 
#   summarize_b2b_round_wins(n_rounds)
```

![](plots/cod_b2b_round_win_prop.png){fig-align="center"}

## Is there evidence for the "hot hand"?

```{r}
#| label: cod_round_win_prop_after_b2b2b_wins
## http://keyonvafa.com/hot-hand/
get_post_streak_prob <- function(n, k, p = 0.5) {
  tosses <- rbinom(n, 1, p)
  runs <- rle(tosses)
  n_neg_after <- length(which(runs$values == 1 & runs$lengths >= k))
  n_pos_after <- sum(runs$lengths[which(runs$values == 1 & runs$lengths >= k)] - k)
  
  ## edge case
  if (n %in% cumsum(runs$lengths)[which(runs$values == 1 & runs$lengths >= k)]) {
    n_neg_after <- n_neg_after - 1
  }
  
  n_pos_after / (n_pos_after + n_neg_after)
}

simulate_post_streak_prob <- function(sims = 1000, ...) {
  rerun(
    sims,
    get_post_streak_prob(...)
  ) |> 
    flatten_dbl() |> 
    mean(na.rm = TRUE)
}
# prob_n6_k2 <- simulate_post_streak_prob(sims = 10000, n = 6, k = 2, p = 0.5)
prob_n6_k3 <- simulate_post_streak_prob(sims = 10000, n = 6, k = 3, p = 0.5)
prob_n11_k3 <- simulate_post_streak_prob(sims = 10000, n = 8, k = 3, p = 0.5)
prob_n11_k3 <- simulate_post_streak_prob(sims = 10000, n = 11, k = 3, p = 0.5)
prob_n10_k1 <- simulate_post_streak_prob(sims = 10000, n = 10, k = 1, p = 0.5)

cod_round_streaks <- cod_rounds |> 
  # filter(round <= 6) |> 
  group_by(year, sheet, series, team) |> 
  mutate(
    won_prior_round2 = lag(win_round, n = 2, default = NA),
    won_prior_round3 = lag(win_round, n = 3, default = NA)
  ) |> 
  ungroup() |>
  select(
    year,
    sheet,
    series,
    team,
    is_offense,
    round,
    win_round,
    won_prior_round,
    won_prior_round2,
    won_prior_round3
  )

cod_round_streaks_after_b2b2b <- cod_round_streaks |> 
  filter(!is.na(won_prior_round2), !is.na(won_prior_round3)) |> 
  count(win_round, won_prior_round, won_prior_round2, won_prior_round3, sort = TRUE)

cod_round_win_prop_after_b2b2b_wins <- cod_round_streaks_after_b2b2b |> 
  filter(won_prior_round, won_prior_round2, won_prior_round3) |> 
  mutate(
    total = sum(n),
    prop = n / total
  ) |> 
  filter(win_round) |> 
  select(n, total, prop)
```

```{r}
#| label: cod_round_win_prop_after_b2b2b_wins-eval
#| eval: true
prob_n6_k3 <- 0.3838163
cod_round_win_prop_after_b2b2b_wins <- tibble(
  n = 621,
  total = 1150
) |> 
  mutate(prop = n / total)
```

```{r}
#| label: summarize_and_compare_win_prop_after_wins
## https://content.iospress.com/articles/journal-of-sports-analytics/jsa200422#app2 suggests that we should look at non-overlapping streaks.
## "To avoid this problem, we examine only the frequency of winning game three after having won games one and two and the frequency of winning game six after having won games four and five". They sort of deduced that win %s > 50% in the third game might constitute momentum, but didn't make strong statements.
summarize_cod_win_prop_after_x_wins <- function(round, ...) {
  cod_round_streaks |> 
    filter(round == !!round) |> 
    count(win_round, won_prior_round, won_prior_round2, ..., sort = TRUE) |> 
    relocate(n) |> 
    drop_na(last_col()) |> 
    filter(won_prior_round, won_prior_round2, ...) |> 
    mutate(
      total = sum(n),
      prop = n / total
    ) |> 
    filter(win_round) |> 
    transmute(round = !!round, n, total, prop)
}

summarize_cod_win_prop_after_b2b_wins <- summarize_cod_win_prop_after_x_wins
summarize_cod_win_prop_after_b2b2b_wins <- function(round) {
  summarize_cod_win_prop_after_x_wins(round = round, won_prior_round3)
}

summarize_and_compare_cod_win_prop_after_wins <- function(ri, add, f) {
  ra <- f(ri)
  rb <- f(ri + add)
  bind_rows(ra, rb)
}

summarize_and_compare_cod_win_prop_after_b2b_wins <- partial(
  summarize_and_compare_cod_win_prop_after_wins,
  add = 3,
  f = summarize_cod_win_prop_after_b2b_wins,
  ... = 
)

summarize_and_compare_cod_win_prop_after_b2b2b_wins <- partial(
  summarize_and_compare_cod_win_prop_after_wins,
  add = 4,
  f = summarize_cod_win_prop_after_b2b2b_wins,
  ... = 
)

cod_win_prop_after_b2b_wins <- seq(3, 8, by = 1) |> 
  map_dfr(
    summarize_and_compare_cod_win_prop_after_b2b_wins,
    .id = 'pair_idx'
  )

cod_win_prop_after_b2b2b_wins <- seq(4, 7, by = 1) |> 
  map_dfr(
    summarize_and_compare_cod_win_prop_after_b2b2b_wins,
    .id = 'pair_idx'
  )
```

<br/><br/>

Round win % after a streak of 3 round wins:

-   Expected: **`r 100 * round(prob_n6_k3, 3)`%**
-   Actual: **`r 100 * round(cod_round_win_prop_after_b2b2b_wins$prop, 3)`%** (`r cod_round_win_prop_after_b2b2b_wins$n` / `r cod_round_win_prop_after_b2b2b_wins$total`)

## Is planting at one site better than the other?

```{r}
#| label: cod_plant_win_prop_proj
cod_map_plant_win_prop <- cod_rounds |> 
  filter(!is.na(plant)) |> 
  filter(is_offense) |> 
  group_by(year, game, map, plant) |> 
  summarize(
    n = n(),
    wins = sum(win_round)
  ) |> 
  ungroup() |> 
  mutate(
    win_prop = wins / n
  ) |> 
  group_by(year, game, map) |> 
  mutate(
    total = sum(n),
    rnk = row_number(-n),
    prop = n / total
  ) |> 
  ungroup()

cod_plant_win_prop <- cod_map_plant_win_prop |>
  mutate(site = ifelse(rnk == 1, 'pri', 'sec')) |> 
  group_by(site) |> 
  summarize(
    across(c(n, wins, total), sum)
  ) |> 
  ungroup() |> 
  mutate(
    win_prop = wins / n,
    prop = n / total
  )

cod_plant_win_prop_proj <- cod_plant_win_prop |> 
  left_join(
    cod_rounds |> 
      filter(is_offense) |> 
      filter(is.na(plant)) |> 
      summarize(
        n_no_plant = n(),
        wins_no_plant = sum(win_round)
      ),
    by = character()
  ) |> 
  mutate(
    n_proj = round(n + prop * n_no_plant),
    wins_proj = round(wins + prop * wins_no_plant),
    win_prop_proj = wins_proj / n_proj
  )

cod_plant_site_prop <- cod_plant_win_prop_proj |> 
  select(site, prop) |> 
  deframe() |> 
  scales::percent(accuracy = 0.1)

cod_plant_site_win_prop <- cod_plant_win_prop_proj |> 
  select(site, win_prop_proj) |> 
  deframe() |> 
  scales::percent(accuracy = 0.1)
```

```{r}
#| label: cod_plant_win_prop_proj-eval
#| eval: true
cod_plant_site_prop <- c(
  'pri' = '60.9%',
  'sec' = '39.1%'
)
cod_plant_site_win_prop <- c(
  'pri' = '47.4%',
  'sec' = '48.5%'
)
```

<br/><br/>

::: columns
::: {.column width="15%"}
:::

::: {.column .fragment width="30%"}
| Plant site |                               \% |
|------------|---------------------------------:|
| Primary    | `r cod_plant_site_prop[['pri']]` |
| Secondary  | `r cod_plant_site_prop[['sec']]` |
:::

::: {.column width="10%"}
:::

::: {.column .fragment width="30%"}
| Plant site |                                Win % |
|------------|-------------------------------------:|
| Primary    | `r cod_plant_site_win_prop[['pri']]` |
| Secondary  | `r cod_plant_site_win_prop[['sec']]` |
:::

::: {.column width="15%"}
:::
:::

## Winning a next game given the series state

```{r}

```
