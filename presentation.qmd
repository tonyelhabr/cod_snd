---
title: "Streaking and Clutching in Round-Based First Person Shooter Esports"
author: "Tony ElHabr"
format:
  revealjs:
    slide-number: true
    incremental: false
    logo: images/cdl_gray.png
    theme: [dark, theme.scss]
execute: 
  include: false
  echo: false
  eval: false
---

```{r}
#| label: setup
#| eval: true
library(dplyr)
library(dplyr)
library(qs)
library(scales)

rounds <- qs::qread('cod_rounds.qs')
```

```{r}
#| label: setup-eval
library(tidyverse)
library(extrafont)
library(ggtext)
library(ggsci)
library(ggnewscale)
blackish_background <- '#191919' ## to match slide background
gray_points <- '#4d4d4d'
gray_text <- '#999999'

font <- 'Titillium Web'
extrafont::loadfonts(quiet = TRUE)
theme_set(theme_minimal())
theme_update(
  text = element_text(family = font),
  title = element_text(size = 14, color = 'white'),
  plot.title = element_text(face = 'bold', size = 20, color = 'white'),
  plot.title.position = 'plot',
  plot.subtitle = element_text(size = 14, color = '#f1f1f1'),
  axis.text = element_text(color = 'white', size = 14),
  axis.title = element_text(size = 14, color = 'white', face = 'bold', hjust = 0.99),
  axis.line = element_blank(),
  panel.grid.major = element_line(color = gray_points),
  panel.grid.minor = element_line(color = gray_points),
  panel.grid.minor.x = element_blank(),
  panel.grid.minor.y = element_blank(),
  strip.text = element_text(color = 'white', size = 16, face = 'bold'),
  plot.margin = margin(10, 10, 10, 10),
  plot.background = element_rect(fill = blackish_background, color = blackish_background),
  plot.caption = element_text(size = 12, color = 'white', hjust = 1),
  plot.caption.position = 'plot',
  plot.tag = ggtext::element_markdown(size = 12, color = 'white', hjust = 0),
  plot.tag.position = c(0.01, 0.01),
  panel.background = element_rect(fill = blackish_background, color = blackish_background)
)
update_geom_defaults('text', list(family = font, size = 10 / .pt, fontface = 'bold'))
update_geom_defaults('point', list(color = 'white'))
update_geom_defaults('segment', list(color = 'white'))
```

## Game types

::: fragment
-   Search and Destroy (SnD) in Call of Duty (COD)
-   2020-2022 Call of Duty League (CDL) matches (qualifiers and majors)
-   4v4.
-   First to 6 round wins
-   Teams swap sides (offense and defense) after every round
:::

::: fragment
-   Plant/Defuse in Valorant
-   Valorant professional league, updated through January 1, 2022
-   5v5
-   First to 13 round wins
-   One team plays offense in 12 consecutive rounds before swapping sides
-   Must win by 2 rounds
:::

## How does a team win a round of COD SnD / Valorant plant/defuse?

::: fragment
1.  One team eliminates all members of the other team prior to a bomb plant.
:::

::: fragment
2.  The offensive team eliminates all members of the defensive team after a bomb plant.
:::

::: fragment
3.  The defensive team defuses the bomb after a bomb plant.
:::

::: fragment
Often the defensive team will try to eliminate all o team members prior to making the defuse, but in some cases, they may try to "ninja" defuse.
:::

::: fragment
4.  The offensive team does not make a plant by the time the round timer ends.
:::

## COD SnD data overview

```{r}
#| label: descriptive-cod-snd-stats
#| eval: true
n_series <- rounds |> 
  distinct(year, sheet, series) |> 
  nrow() |> 
  scales::comma()

n_rounds <- rounds |> 
  distinct(year, sheet, series, round) |> 
  nrow() |> 
  scales::comma()

o_win_prop_const <- rounds |> 
  filter(is_offense) |> 
  count(win_round) |> 
  mutate(prop = n / sum(n)) |> 
  filter(win_round) |> 
  pull(prop)
o_win_pct <- scales::percent(o_win_prop_const, accuracy = 1)

plant_pct <- rounds |>
  filter(is_offense) |> 
  count(makes_plant = !is.na(plant)) |> 
  mutate(prop = n / sum(n)) |> 
  filter(makes_plant) |> 
  pull(prop) |> 
  scales::percent(accuracy = 1)

o_plant_and_win_pct <- rounds |> 
  filter(is_offense, !is.na(plant)) |> 
  count(win_round) |> 
  mutate(prop = n / sum(n)) |> 
  filter(win_round) |> 
  pull(prop) |> 
  scales::percent(accuracy = 1)

o_first_blood_win_pct <- rounds |> 
  filter(!is.na(earned_fb)) |> 
  filter(earned_fb) |> 
  count(win_round) |> 
  mutate(prop = n / sum(n)) |> 
  filter(win_round) |> 
  pull(prop) |> 
  scales::percent(accuracy = 1)
```

::: fragment
-   Total series: **`r n_series`**
:::

::: fragment
-   Total rounds: **`r n_rounds`**
:::

::: fragment
-   Offensive plant %: **`r plant_pct`**
:::

::: fragment
-   Offensive win %: **`r o_win_pct`**
:::

::: fragment
-   Win % when planting: **`r o_plant_and_win_pct`**
:::

::: fragment
-   Win % when earning first blood: **`r o_first_blood_win_pct`**
:::

## What are your chances of winning a round, given the series state?

```{r}
#| label: cod_heatmap_prep
round_and_series_win_prop_by_side <- rounds |> 
  group_by(pre_cumu_w, pre_cumu_l, is_offense) |> 
  summarize(
    n = n(),
    across(c(win_round, win_series), sum)
  ) |> 
  ungroup() |> 
  mutate(
    win_round_prop = win_round / n,
    win_series_prop = win_series / n
  )

o_win_prop <- round_and_series_win_prop_by_side |> 
  filter(is_offense) |> 
  mutate(
    diff_win_round_prop = win_round_prop - !!o_win_prop_const
  )

e_o_win_series_prop <- crossing(
  pre_cumu_w = 0:5,
  pre_cumu_l = 0:5
) |> 
  mutate(
    n_remain_max = 11 - (pre_cumu_w + pre_cumu_l),
    n_remain_w = 6 - pre_cumu_w,
    ## can i account for offense in this by rotating?
    e_win_series_prop = map2_dbl(n_remain_w, n_remain_max, ~sum(dbinom(..1:..2, ..2, 0.5)))
  )

o_win_prop <- o_win_prop |> 
  inner_join(
    e_o_win_series_prop |> select(pre_cumu_w, pre_cumu_l, e_win_series_prop),
    by = c('pre_cumu_w', 'pre_cumu_l')
  ) |> 
  mutate(
    diff_win_series_prop = win_series_prop - e_win_series_prop
  )

# round_and_series_win_prop <- rounds |> 
#   group_by(pre_cumu_w, pre_cumu_l) |> 
#   summarize(
#     n = n(),
#     across(c(win_round, win_series), sum)
#   ) |> 
#   ungroup() |> 
#   mutate(
#     win_round_prop = win_round / n,
#     win_series_prop = win_series / n
#   )
# 
# pluck_round_win_prop <- function(w = 0, l = 0) {
#   round_and_series_win_prop |> 
#     filter(pre_cumu_w == w, pre_cumu_l == l) |> 
#     pull(win_round_prop)
# }
# 
# compute_conditional_probs <- function(
    #     p00 = 0.5,
#     p10 = p00,
#     p20 = p00,
#     p30 = p00,
#     p40 = p00,
#     p50 = p00,
#     p11 = p00, p21 = p00, p31 = p00, p41 = p00, p51 = p00,
#     p52 = p00, p53 = p00, p54 = p00
# ) {
#   pr6 <- p10 * p20 * p30 * p40 * p50
#   # pr7 <- p51 * (p10 * p20 * p30 * p40 * (1 - p50) + p10 * p20 * p30 * (1 - p40) * p41 + p10 * p20 * (1 - p30) * p41 + p10 * (1 - p20) * p31 * p41 + (1 - p10) * p21 * p31 * p41)
#   pr7 <- (
#     (p00 * p10 * p20 * p30 * p40 * (1 - p50) * p51) +   ## aaaaaba
#     (p00 * p10 * p20 * p30 * (1 - p40) * p41 * p51) + ## aaaabaa
#     (p00 * p10 * p20 * (1 - p30) * p31 * p41 * p51) + ## aaabaaa
#     (p00 * p10 * (1 - p20) * p21 * p31 * p41 * p51) + ## aabaaaa
#     (p00 * (1 - p10) * p11 * p21 * p31 * p41 * p51) + ## abaaaaa
#     ((1 - p00) * (1 - p10) * p11 * p21 * p31 * p41 * p51) + ## baaaaaa
#     
#     ((1 - p00) * p10 * p20 * p30 * p40 * (1 - p50) * p51) + ## bbbbbab
#     ((1 - p00) * p10 * p20 * p30 * (1 - p40) * p41 * p51) + ## bbbbabb
#     ((1 - p00) * p10 * p20 * (1 - p30) * p31 * p41 * p51) + ## bbbabbb
#     ((1 - p00) * p10 * (1 - p20) * p21 * p31 * p41 * p51) + ## bbabbbb
#     ((1 - p00) * (1 - p10) * (1 - p11) * p21 * p31 * p41 * p51) + ## babbbbb
#     (p00 * (1 - p10) * (1 - p11) * p21 * p31 * p41 * p51) ## abbbbbb
# )
#   
#   ## NOTE: pr8 and pr9 are broken. although we can use the simple subtraction of other probabilities for pr10 and pr11 like pr6 and pr7 in a 7 game series, they aren't valid for pr8 and pr9 in an 11 game series.
#   pr8 <- (1 - pr6 - pr7) * p52
#   pr9 <- (1 - pr6 - pr7 - pr8) * p53
#   pr10 <- (1 - pr6 - pr7 - pr8 - pr9) * p54
#   pr11 <- 1 - pr6 - pr7 - pr8 - pr9 - pr10
#   tibble(
#     n_rounds = 6L:11L,
#     p = c(pr6, pr7, pr8, pr9, pr10, pr11)
#   )
# }
# 
# ## pr6 and pr7 should match up with what we see later with `possibilities`
# conditional_series_probs <- compute_conditional_probs(
#   p00 = pluck_round_win_prop(0, 0),
#   p10 = pluck_round_win_prop(1, 0),
#   p20 = pluck_round_win_prop(2, 0),
#   p30 = pluck_round_win_prop(3, 0),
#   p40 = pluck_round_win_prop(4, 0),
#   p50 = pluck_round_win_prop(5, 0),
#   p11 = pluck_round_win_prop(1, 1),
#   p21 = pluck_round_win_prop(2, 1),
#   p31 = pluck_round_win_prop(3, 1),
#   p41 = pluck_round_win_prop(4, 1),
#   p51 = pluck_round_win_prop(5, 1),
#   p52 = pluck_round_win_prop(5, 2),
#   p53 = pluck_round_win_prop(5, 3),
#   p54 = pluck_round_win_prop(5, 4)
# )

common_cod_labs <- function(...) {
  list(
    ...,
    labs(
      caption = 'CDL SnD Major and Weekly matches, 2020 - present'
    )
  )
}

common_cod_heatmap_layers <- function(...) {
  list(
    ...,
    guides(
      fill = 'none'
    ),
    scale_x_continuous(
      labels = 0:5,
      breaks = seq(0.5, 5.5, by = 1),
      expand = c(0, 0)
    ),
    scale_y_continuous(
      labels = 0:5,
      breaks = seq(0.5, 5.5, by = 1),
      expand = c(0, 0),
      sec.axis = sec_axis(
        trans = I, 
        name = ' ', 
        breaks = seq(0.5, 5.5, by = 1), 
        labels = rep('', 6)
      )
    ),
    theme(
      panel.grid.major = element_blank(),
      axis.title = element_text(hjust = 0.5),
      plot.title = ggtext::element_markdown(hjust = 0.5),
      axis.text = element_text(size = 16, face = 'bold')
    ),
    common_cod_labs(),
    labs(
      x = "Offensive Team's # of Pre-Round Wins",
      y = "Defensive Team's # of Pre-Round Wins"
    )
  )
}

.dpi <- 300
save_for_slide <- function(
    p, 
    filename = paste0(str_remove(deparse(substitute(p)), '^p_'), '.png'), 
    width = 7.5, 
    height = width / 1.5,
    units = 'px',
    dpi = .dpi,
    ...
) {
  ggsave(
    plot = p,
    filename = filename,
    width = width * dpi,
    height = height * dpi,
    units = units,
    dpi = dpi,
    ...
  )
}

heatmap_tile <- function(..., .fill) {
  list(
    ...,
    geom_rect(
      color = blackish_background,
      aes(
        fill = .data[[.fill]],
        xmin = pre_cumu_w, 
        ymin = pre_cumu_l,
        xmax = pre_cumu_w + 1,
        ymax = pre_cumu_l + 1
      )
    )
  )
}

heatmap_seq_labeller <- function(.data, .label, .num) {
  sprintf(
    '%s\n(%s/%s)', 
    scales::percent(.data[[.label]], accuracy = 1), 
    scales::comma(.data[[.num]]), 
    scales::comma(.data$n)
  )
}

heatmap_text_layer <- function(..., .op, .data, .label, .num, .color, .threshold, .labeller) {
  list(
    ...,
    geom_text(
      data = .data |> filter(`.op`(.data[[.label]], .threshold)),
      # family = font,
      color = .color,
      size = 11 / .pt,
      fontface = 'bold',
      aes(
        x = pre_cumu_w + 0.5, 
        y = pre_cumu_l + 0.5,
        label = .labeller(.data = .data, .label = .label, .num)
      )
    )
  )
}

heatmap_text_layers <- function(..., .f) {
  list(
    ...,
    .f(.emphasize = 'low'),
    .f(.emphasize = 'high')
  )
}
```

```{r}
#| label: p_o_round_win_prop
o_round_win_text_layer <- function(..., .emphasize) {
  if(.emphasize == 'low') {
    op <- `<`
    .color <- blackish_background
  } else {
    op <- `>=`
    .color <- 'white'
  }
  list(
    ...,
    heatmap_text_layer(
      .data = o_win_prop,
      .op = op,
      .label = 'win_round_prop',
      .num = 'win_round',
      .color = .color,
      .threshold = 0.52,
      .labeller = heatmap_seq_labeller
    )
  )
}

p_o_round_win_prop <- o_win_prop |> 
  ggplot() +
  common_cod_heatmap_layers() +
  heatmap_tile(.fill = 'win_round_prop') +
  heatmap_text_layers(.f = o_round_win_text_layer) +
  ggsci::scale_fill_material('teal') +
  labs(
    title = 'Offensive Round Win %'
  )
p_o_round_win_prop
save_for_slide(p_o_round_win_prop)
```

::: notes
-   This should hint at what I'm calling the "4-4" phenomenon, where the o round win % is dramatically higher than adjacent scenarios (3-4, 4-3, 5-4, 4-5, and even 3-3 or 5-5).
-   Note that round win %s are lower than one might expect in 0-5 and 1-5 states.
:::

![](o_round_win_prop.png){fig-align="center"}

## What are your chances of winning a round, given the series state?

```{r}
#| label: p_o_round_win_prop_over_expected
# I have no idea why I need to add .num here... keeps erroring otherwise
heatmap_div_labeller <- function(.data, .label, .num) {
  sprintf(
    '%+.1f\n(%s)', 
    100 * .data[[.label]], 
    scales::comma(.data$n)
  )
}

o_round_win_over_expected_text_layer <- function(..., .emphasize) {
  if(.emphasize == 'low') {
    op <- `<`
    .color <- 'white'
  } else {
    op <- `>=`
    .color <- blackish_background
  }
  list(
    ...,
    heatmap_text_layer(
      .data = o_win_prop,
      .op = op,
      .label = 'diff_win_round_prop',
      .color = .color,
      .threshold = -0.1,
      .labeller = heatmap_div_labeller
    )
  )
}

extract_ggsci_mid_color <- function(palette) {
  ggsci::pal_material(palette, n = 3)(2)[2]
}

max_diff_win_round_prop <- max(abs(o_win_prop$diff_win_round_prop))
p_o_round_win_prop_over_expected <- o_win_prop |> 
  ggplot() +
  common_cod_heatmap_layers() +
  heatmap_tile(.fill = 'diff_win_round_prop') +
  heatmap_text_layers(.f = o_round_win_over_expected_text_layer) +
  scale_fill_gradient2(
    low = extract_ggsci_mid_color('purple'),
    high = extract_ggsci_mid_color('green'),
    mid = 'white',
    midpoint = 0,
    limits = c(
      -max_diff_win_round_prop, 
      +max_diff_win_round_prop
    )
  ) +
  labs(
    title = 'Offensive Round Win % Over Expected'
  )
p_o_round_win_prop_over_expected
save_for_slide(p_o_round_win_prop_over_expected)
```

::: notes
-   This should emphasize the ends of the spectrum seen on the previous graph.
:::

![](o_round_win_prop_over_expected.png){fig-align="center"}

## What are your chances of winning the series, given the series state?

```{r}
#| label: p_o_series_win_prop
add_o_series_win_text_layer <- function(..., .emphasize) {
  if(.emphasize == 'low') {
    op <- `<`
    .color <- blackish_background
  } else {
    op <- `>=`
    .color <- 'white'
  }
  list(
    ...,
    heatmap_text_layer(
      .data = o_win_prop,
      .op = op,
      .label = 'win_series_prop',
      .num = 'win_series',
      .color = .color,
      .threshold = 0.8,
      .labeller = heatmap_seq_labeller
    )
  )
}

p_o_series_win_prop <- o_win_prop |> 
  ggplot() +
  common_cod_heatmap_layers() +
  heatmap_tile(.fill = 'win_series_prop') +
  heatmap_text_layers(.f = add_o_series_win_text_layer) +
  ggsci::scale_fill_material('orange') +
  labs(
    title = 'Offensive Series Win %'
  )
p_o_series_win_prop
save_for_slide(p_o_series_win_prop)
```

::: notes
-   This is mostly just for reference. I think the next slide should have more insight, since it's harder to have a prior understanding about the probability of winning the series given a round state.
:::

![](o_series_win_prop.png){fig-align="center"}

## What are your chances of winning the series, given the series state?

```{r}
#| label: p_o_series_win_prop_over_expected
add_o_series_win_over_expected_text_layer <- function(..., .emphasize) {
  if(.emphasize == 'low') {
    op <- `<`
    .color <- blackish_background
  } else {
    op <- `>=`
    .color <- 'white'
  }
  list(
    ...,
    heatmap_text_layer(
      .data = o_win_prop,
      .op = op,
      .label = 'diff_win_series_prop',
      .color = .color,
      .threshold = 0.08,
      .labeller = heatmap_div_labeller
    )
  )
}

max_diff_win_series_prop <- max(abs(o_win_prop$diff_win_series_prop))
p_o_series_win_prop_over_expected <- o_win_prop |> 
  ggplot() +
  common_cod_heatmap_layers() +
  heatmap_tile(.fill = 'diff_win_series_prop') +
  heatmap_text_layers(.f = add_o_series_win_over_expected_text_layer) +
  scale_fill_gradient2(
    low = extract_ggsci_mid_color('brown'),
    high = extract_ggsci_mid_color('cyan'),
    mid = 'white',
    midpoint = 0,
    limits = c(
      -max_diff_win_series_prop, 
      +max_diff_win_series_prop
    )
  ) +
  labs(
    title = 'Offensive Series Win % Over Expected'
  )
p_o_series_win_prop_over_expected
save_for_slide(p_o_series_win_prop_over_expected)
```

::: notes
-   Note the 4-4 and 2-4 series win percentages.
:::

![](o_series_win_prop_over_expected.png){fig-align="center"}

## Are offensive win %'s different in round 1?

```{r}
#| label: o_win_r1_vs_post_round_pro
calculate_o_round_win_prop <- function(df) {
  df |> 
    count(year, game, map, is_offense, win_round) |> 
    group_by(map, is_offense) |> 
    mutate(total = sum(n), prop = n / total) |> 
    ungroup() |>
    filter(win_round, is_offense) |>
    select(
      year,
      game,
      map,
      rounds_won = n,
      total_rounds = total,
      win_round_prop = prop
    ) |>
    arrange(desc(win_round_prop))
}

# https://raw.githubusercontent.com/dgrtwo/splittestr/master/R/vectorized-prop-test.R
vectorized_prop_test_approx <- function(a, b, c, d) {
  n1 <- a + b
  n2 <- c + d
  n <- n1 + n2
  p <- (a + c) / n
  E <- cbind(p * n1, (1 - p) * n1, p * n2, (1 - p) * n2)
  
  x <- cbind(a, b, c, d)
  
  DELTA <- a / n1 - c / n2
  YATES <- pmin(.5, abs(DELTA) / sum(1 / n1 + 1 / n2))
  
  STATISTIC <- rowSums((abs(x - E) - YATES)^2 / E)
  PVAL <- pchisq(STATISTIC, 1, lower.tail = FALSE)
  PVAL
}

vectorized_prop_test_exact <- function(a, b, c, d) {
  sapply(seq_along(a), function(i) {
    fisher.test(cbind(c(a[i], c[i]), c(b[i], d[i])))$p.value
  })
}

vectorized_prop_test <- function(x1, n1, x2, n2, conf.level = .95) {
  a <- x1
  b <- n1 - x1
  c <- x2
  d <- n2 - x2
  
  # if any values are < 20, use Fisher's exact test
  exact <- (a < 20 | b < 20 | c < 20 | d < 20)
  
  pvalue <- rep(NA, length(a))
  
  if (any(exact)) {
    pvalue[exact] <- vectorized_prop_test_exact(a[exact], b[exact], c[exact], d[exact])
  }
  if (any(!exact)) {
    pvalue[!exact] <- vectorized_prop_test_approx(a[!exact], b[!exact], c[!exact], d[!exact])
  }
  
  mu1 <- a / (a + b)
  mu2 <- c / (c + d)
  
  ## confidence interval
  alpha2 <- (1 - conf.level) / 2
  DELTA <- mu2 - mu1
  WIDTH <- qnorm(alpha2)
  alpha <- (a + .5) / (a + b + 1)
  beta <- (c + .5) / (c + d + 1)
  
  n <- n1 + n2
  YATES <- pmin(.5, abs(DELTA) / sum(1 / n1 + 1 / n2))
  
  z <- qnorm((1 + conf.level) / 2)
  WIDTH <- z * sqrt(mu1 * (1 - mu1) / n1 + mu2 * (1 - mu2) / n2)
  
  tibble(
    estimate = DELTA,
    conf.low = pmax(DELTA - WIDTH, -1),
    conf.high = pmin(DELTA + WIDTH, 1),
    p.value = pvalue
  )
}

summarize_o_round_win_prop <- function(.round) {
  
  specified_round <- rounds |> 
    filter(round == .round) |> 
    calculate_o_round_win_prop()
  
  post_rounds <- rounds |> 
    filter(round > .round) |> 
    calculate_o_round_win_prop()
  
  specified_round |> 
    inner_join(
      post_rounds |> rename_with(~sprintf('post_%s', .x), -c(year, game, map)),
      by = c('year', 'game', 'map')
    ) |> 
    mutate(round = .round, .after = 'map') |> 
    arrange(desc(win_round_prop)) |> 
    mutate(
      prop_test = vectorized_prop_test(rounds_won, total_rounds, post_rounds_won, post_total_rounds),
      p_value = prop_test$p.value
    ) |> 
    arrange(p_value) |> 
    mutate(
      diff_prop = post_win_round_prop - win_round_prop,
      dir = factor(sign(diff_prop)),
      is_significant = p_value < 0.05,
      label = sprintf('%s - %s (%s)', map, game, year)
    )
}

o_win_rx_prop_pal <- c(
  `-1` = extract_ggsci_mid_color('pink'),
  `1` = extract_ggsci_mid_color('teal')
)

arw <- arrow(length = unit(5, 'pt'), type = 'closed')

plot_round_vs_post_round_slope_chart <- function(.round) {
  o_win_rx_prop <- summarize_o_round_win_prop(.round)
  x1_label <- sprintf('Round %d<br/>offensive win %%', .round)
  x2_label <- sprintf('Post-round %d<br/>offensive win %%', .round)
  
  min_o_win_rx_prop <- o_win_rx_prop |> slice_min(diff_prop, n = 1)
  max_o_win_rx_prop <- o_win_rx_prop |> slice_max(diff_prop, n = 1)
  minmax_labels <- c(min_o_win_rx_prop$label, max_o_win_rx_prop$label)
  
  p <- o_win_rx_prop |> 
    ggplot() +
    geom_vline(
      data = tibble(),
      aes(xintercept = c(1, 2)), 
      color = gray_points
    ) +
    geom_hline(
      data = tibble(),
      aes(yintercept = c(0.25, 0.5, 0.75)), 
      linetype = 2,
      color = gray_points
    ) +
    geom_segment(
      data = o_win_rx_prop |> 
        mutate(
          big_segment = label %in% minmax_labels
        ),
      show.legend = FALSE,
      aes(
        x = 1,
        xend = 2,
        y = win_round_prop,
        yend = post_win_round_prop,
        color = dir,
        size = big_segment,
        group = label
      )
    ) +
    geom_text(
      data = tibble(
        y = c(0.25, 0.75)
      ) |> 
        mutate(
          lab = sprintf('%s%%', round(100 * y))
        ),
      aes(x = 2, y = y, label = lab), 
      size = 12 / .pt,
      hjust = -0.05,
      vjust = -0.25,
      fontface = 'bold',
      color = 'white'
    ) +
    ggtext::geom_richtext(
      fill = blackish_background, 
      label.color = NA,
      data = tibble(
        x = c(1, 2),
        y = rep(0.7, 2),
        lab = c(x1_label, x2_label)
      ),
      aes(x = x, y = y, label = lab), 
      size = 9 / .pt,
      hjust = 0.5,
      vjust = 0.5,
      family = font,
      fontface = 'bold',
      color = 'white'
    ) +
    ggrepel::geom_text_repel(
      data = o_win_rx_prop |> 
        filter(label %in% !!minmax_labels),
      aes(x = 1, y = win_round_prop, label = label),
      family = font,
      fontface = 'bold',
      color = 'white',
      size = 9 / .pt,
      hjust = 'right', 
      nudge_x = -0.1,
      direction = 'y'
    ) +
    ggrepel::geom_text_repel(
      data = o_win_rx_prop |> 
        filter(!(label %in% !!minmax_labels)),
      aes(x = 2, y = post_win_round_prop, label = label),
      family = font,
      color = gray_text,
      size = 9 / .pt,
      hjust = 'left', 
      nudge_x = 0.1,
      direction = 'y'
    ) +
    scale_x_continuous(
      position = 'top',
      breaks = c(1, 2),
      expand = expansion(mult = 0.5)
    ) +
    scale_y_continuous(
      limits = c(0.25, 0.75)
    ) +
    scale_size_manual(
      values = c(
        `FALSE` = 0.5,
        `TRUE` = 2
      )
    ) +
    scale_color_manual(
      name = NULL,
      values = o_win_rx_prop_pal
    ) +
    theme(
      plot.title = element_text(hjust = 0.5),
      panel.grid.major = element_blank(),
      axis.text.x = element_blank(),
      axis.text.y = element_blank()
    ) +
    labs(
      x = NULL,
      y = NULL
    )
  list(
    plot = p,
    data = o_win_rx_prop,
    largest_neg_diff_prop = min_o_win_rx_prop$diff_prop,
    largest_pos_diff_prop = max_o_win_rx_prop$diff_prop
  )
}

res_r1 <- plot_round_vs_post_round_slope_chart(1)

p_o_win_r1_vs_post_round_prop <- res_r1$plot +
  geom_curve(
    data = tibble(),
    aes(x = 1.2, y = 0.65, xend = 1.1, yend = 0.63),
    curvature = 0.2, 
    color = o_win_rx_prop_pal[["-1"]], 
    arrow = arw
  ) +
  geom_curve(
    data = tibble(),
    aes(x = 1.24, y = 0.27, xend = 1.1, yend = 0.27),
    curvature = 0-.2, 
    color = o_win_rx_prop_pal[["1"]], 
    arrow = arw
  ) +
  geom_text(
    data = tibble(
      x = c(1.2, 1.24),
      y = c(0.65, 0.27),
      hjust = c(0, 0),
      vjust = c(0.5, 0.5),
      lab = c(
        sprintf(
          'Largest negative percent difference in round 1\nvs. all other round win percentages (%+.0f%%).', 
          100 * res_r1$largest_neg_diff_prop
        ),
        sprintf(
          'Largest positive percent difference (%+.0f%%).\nOnly significant difference (p value < 0.01).',
          100 * res_r1$largest_pos_diff_prop
        )
      )
    ),
    color = 'white',
    size = 9 / .pt,
    aes(x = x, y = y, hjust = hjust, vjust = vjust, label = lab)
  )
p_o_win_r1_vs_post_round_prop
save_for_slide(p_o_win_r1_vs_post_round_prop)
```

![](o_win_r1_vs_post_round_prop.png){fig-align="center"}

::: notes
-   This might be considered an "information-neutral" setting
:::

## Are offensive win %'s different in round 2?

```{r}
#| label: o_win_r2_vs_post_round_pro
res_r2 <- plot_round_vs_post_round_slope_chart(2)
res_r2$plot
save_for_slide(
  res_r2$plot,
  filename = 'o_win_r2_vs_post_round_prop.png'
)
```

![](o_win_r2_vs_post_round_prop.png){fig-align="center"}

::: notes
-   no trend
:::

## What are the most common series winning states?

```{r}
#| label: p_series_outcome_prop_over_expected
# https://content.iospress.com/articles/journal-of-sports-analytics/jsa200422
prob_of_series_lasting_n_games <- function(n, p = 0.5, max_rounds = 11) {
  s <- ceiling(max_rounds / 2)
  (factorial(n - 1) / (factorial(s - 1) * factorial(n - s))) * (p^s * (1 - p)^(n - s) + p^(n - s) * (1 - p)^s)
}

possibilities_of_outcomes <- function(m, n) {
  factorial(m + n) / (factorial(m) * factorial(n))
}

actual_series_streaks <- rounds |> 
  filter(win_series) |> 
  mutate(across(win_round, as.integer)) |> 
  group_by(year, event, series) |> 
  summarize(
    wins = max(cumu_w),
    losses = max(cumu_l),
    ws = paste0(win_round, collapse = '')
  ) |> 
  ungroup() |> 
  mutate(n_rounds = wins + losses) |> 
  unite(
    record, wins, losses, sep = '-'
  ) |> 
  count(n_rounds, record, ws, sort = TRUE) |> 
  mutate(prop = n / sum(n))

possibilities <- tibble(
  n_rounds = 6L:11L
) |> 
  mutate(
    series_prop = map_dbl(n_rounds, prob_of_series_lasting_n_games),
    possibilities = map2_dbl(6, n_rounds - 6, possibilities_of_outcomes)
  ) |> 
  transmute(
    n_rounds,
    series_prop,
    record = sprintf('6-%d', n_rounds - 6),
    prop = series_prop / possibilities
  )

series_streaks <- inner_join(
  actual_series_streaks |> 
    rename_with(~sprintf('%s_actual', .x), c(n, prop)),
  possibilities |> 
    rename_with(~sprintf('%s_expected', .x), prop),
  by = 'n_rounds'
) |> 
  mutate(
    prop_diff = prop_actual - prop_expected
  ) |> 
  arrange(desc(abs(prop_diff)))
# series_streaks |> filter(is.na(n_actual))

## 6-0, 6-1, and some combos of 6-5 occur more often than expected
series_streak_props <- series_streaks |> 
  filter(!is.na(n_actual)) |> 
  mutate(
    prop_diff = prop_actual - prop_expected,
    total_actual = sum(n_actual),
    n_expected = round(prop_expected * total_actual),
    p = vectorized_prop_test(n_actual, total_actual, n_expected, total_actual)
  ) |> 
  select(-total_actual) |> 
  unnest_wider(p) |> 
  arrange(p.value)

## 6-0 and 6-1 occur more often than expected
series_outcome_prop <- full_join(
  actual_series_streaks |> 
    group_by(record) |> 
    summarize(
      across(n, sum)
    ) |> 
    mutate(prop = n / sum(n)) |> 
    rename_with(~sprintf('%s_actual', .x), c(n, prop)),
  possibilities |> 
    select(record, prop_expected = series_prop),
  by = 'record'
) |> 
  mutate(
    prop_diff = prop_actual - prop_expected,
    total_actual = sum(n_actual),
    n_expected = round(prop_expected * total_actual),
    p = vectorized_prop_test(n_actual, total_actual, n_expected, total_actual)
  ) |> 
  select(-total_actual) |> 
  unnest_wider(p) |> 
  arrange(p.value)

long_series_outcome_prop <- series_outcome_prop |>
  select(
    record,
    n = n_actual,
    `3` = prop_actual,
    `2` = prop_expected,
    `1` = prop_diff
  ) |> 
  pivot_longer(
    matches('[123]'),
    names_to = 'outcome_idx',
    values_to = 'value'
  ) |> 
  mutate(across(outcome_idx, as.integer))

max_diff_series_outcome_prop <- long_series_outcome_prop |> 
  filter(outcome_idx == 1) |> 
  pull(value) |> 
  abs() |> 
  max()

p_series_outcome_prop_over_expected <- long_series_outcome_prop |> 
  ggplot() +
  aes(x = record, y = outcome_idx) +
  geom_tile(
    data = long_series_outcome_prop |> filter(outcome_idx > 1),
    show.legend = FALSE,
    # height = 0.8,
    aes(fill = value)
  ) +
  ggsci::scale_fill_material(
    palette = 'deep-orange'
  ) +
  ggnewscale::new_scale_fill() +
  geom_tile(
    data = long_series_outcome_prop |> filter(outcome_idx == 1),
    show.legend = FALSE,
    height = 0.8,
    aes(fill = value)
  ) +
  scale_fill_gradient2(
    low = extract_ggsci_mid_color('purple'),
    high = extract_ggsci_mid_color('green'),
    mid = 'white',
    midpoint = 0,
    limits = c(
      -max_diff_series_outcome_prop, 
      +max_diff_series_outcome_prop
    )
  ) +
  geom_text(
    data = long_series_outcome_prop |> filter(outcome_idx == 3),
    color = blackish_background,
    size = 11 / .pt,
    aes(label = sprintf('%.1f%%\n(%s)', 100 * value, scales::comma(n)))
  ) +
  geom_text(
    data = long_series_outcome_prop |> filter(outcome_idx == 2),
    color = blackish_background,
    size = 11 / .pt,
    aes(label = sprintf('%.1f%%', 100 * value))
  ) +
  geom_text(
    data = long_series_outcome_prop |> filter(outcome_idx == 1) |> filter(abs(value) != max(abs(value))),
    color = blackish_background,
    size = 11 / .pt,
    aes(label = sprintf('%+.1f%%', 100 * value))
  ) +
  geom_text(
    data = long_series_outcome_prop |> filter(outcome_idx == 1) |> filter(abs(value) == max(abs(value))),
    color = 'white',
    size = 11 / .pt,
    
    aes(label = sprintf('%+.1f%%', 100 * value))
  ) +
  scale_x_discrete(
    position = 'top',
    expand = c(0, 0)
  ) +
  scale_y_continuous(
    labels = c('Diff.', 'Expected', 'Actual'),
    breaks = 1:3,
    expand = c(0, 0)
  ) +
  theme(
    panel.grid.major = element_blank(),
    axis.title = element_text(hjust = 0.5),
    plot.title = ggtext::element_markdown(hjust = 0.5),
    axis.text = element_text(size = 16, face = 'bold')
  ) +
  labs(
    title = 'Series outcome %',
    x = NULL,
    y = NULL
  ) +
  common_cod_labs() 
p_series_outcome_prop_over_expected
save_for_slide(p_series_outcome_prop_over_expected)
```

![](series_outcome_prop_over_expected.png){fig-align="center"}

::: notes
-   There should be evidence of 6-0's and 6-1's are more frequent than expected given 50-50% chances.
-   Notably 6-4's occur less frequently than expected
-   p-values are not significant for any
:::

## When do back-to-back round wins occur?

```{r}
#| label: p_b2b_round_win_prop
summarize_b2b_round_wins <- function(df, ...) {
  df |> 
    arrange(year, sheet, series, team, round) |> 
    group_by(year, sheet, series, team) |> 
    mutate(
      b2b_round_wins = win_round & lag(win_round)
    ) |> 
    ungroup() |> 
    filter(round > 1L) |> 
    count(..., round, b2b_round_wins) |> 
    group_by(..., round) |> 
    mutate(total = sum(n), prop = n / total) |> 
    ungroup() |> 
    filter(b2b_round_wins) |> 
    select(-b2b_round_wins)
}

## now accounting for number of rounds that end up being played...
## seems like there is interesting behavior in the last round, regardless `n_rounds`
b2b_round_win_prop <- rounds |> 
  filter(n_rounds > 6L) |> 
  summarize_b2b_round_wins(n_rounds) |> 
  group_by(n_rounds) |> 
  mutate(
    z = (n - mean(n)) / sd(n),
    rnk = row_number(desc(n))
  ) |> 
  ungroup()

b2b_round_win_prop_tile_layer <- function(..., .round, .palette, .is_new = TRUE) {
  
  init <- if(!.is_new) {
    list()
  } else {
    ggnewscale::new_scale_fill()
  }
  
  list(
    ...,
    init,
    geom_tile(
      data = b2b_round_win_prop |> filter(n_rounds == .round),
      color = blackish_background,
      height = 0.8,
      show.legend = FALSE,
      aes(
        fill = z,
        x = round + 0.5, 
        y = n_rounds + 0.5
      )
    ),
    ggsci::scale_fill_material(palette = .palette) 
  )
}

b2b_round_win_prop_text_layer <- function(..., .emphasize) {
  if(.emphasize == 'low') {
    op <- `>`
    .color <- blackish_background
  } else {
    op <- `==`
    .color <- 'white'
  }
  list(
    ...,
    geom_text(
      data = b2b_round_win_prop |> filter(`op`(rnk, 1)),
      color = .color,
      size = 11 / .pt,
      fontface = 'bold',
      aes(
        label = sprintf('%s\n(%s)', scales::percent(prop, accuracy = 1), scales::comma(n)),
        x = round + 0.5, 
        y = n_rounds + 0.5
      )
    )
  )
}

b2b_round_win_prop_text_layers <- function(...) {
  list(
    ...,
    b2b_round_win_prop_text_layer(.emphasize = 'low'),
    b2b_round_win_prop_text_layer(.emphasize = 'high')
  )
}

b2b_round_win_prop_arws <- tibble(
  x = c(9.3, 9.4, 9.75, 10),
  y = c(8.25, 8.5, 8.75, 8.75),
  xend = c(8.1, 9.1, 9.5, 10.5),
  yend = c(7.5, 8.5, 9, 10),
  curvature = c(-0.2, -0.1, 0.1, 0.2)
) |> 
  mutate(
    rn = row_number()
  )

p_b2b_round_win_prop <- b2b_round_win_prop |> 
  ggplot() +
  b2b_round_win_prop_tile_layer(.round = 7, .palette = 'pink', .is_new = FALSE) +
  b2b_round_win_prop_tile_layer(.round = 8, .palette = 'light-blue') +
  b2b_round_win_prop_tile_layer(.round = 9, .palette = 'light-green') +
  b2b_round_win_prop_tile_layer(.round = 10, .palette = 'amber') +
  b2b_round_win_prop_tile_layer(.round = 11, .palette = 'deep-orange') +
  b2b_round_win_prop_text_layers() +
  scale_x_continuous(
    labels = 2:11,
    breaks = seq(2.5, 11.5, by = 1),
    expand = c(0, 0.5)
  ) +
  scale_y_continuous(
    labels = 7:11,
    breaks = seq(7.5, 11.5, by = 1),
    expand = c(0, 0)
  ) +
  theme(
    panel.grid.major = element_blank(),
    axis.title = element_text(hjust = 0.5),
    plot.title = ggtext::element_markdown(hjust = 0.5),
    axis.text = element_text(size = 16, face = 'bold')
  ) +
  common_cod_labs() +
  labs(
    title = 'Back-to-back round win %',
    x = 'Round',
    y = '# of Rounds in Complete Series'
  ) + 
  geom_text(
    data = tibble(
      label = 'Back-to-back wins occur most\nfrequently in the last round.',
      x = 9.5,
      y = 8.5
    ),
    size = 9 / .pt,
    fontface = 'bold',
    color = 'white',
    hjust = 0,
    vjust = 0.5,
    aes(x = x, y = y, label = label)
  ) +
  map(
    b2b_round_win_prop_arws |> group_split(rn), 
    function(.x) {
      geom_curve(
        data = data.frame(),
        color = 'white',
        arrow = arw,
        aes(x = .x$x, y = .x$y, xend = .x$xend, yend = .x$yend),
        curvature = .x$curvature
      )
    }
  )
save_for_slide(p_b2b_round_win_prop)
# ## now accounting for number of rounds that end up being played AND series winners...
# rounds |> 
#   filter(win_series, n_rounds > 6L) |> 
#   summarize_b2b_round_wins(n_rounds)
# 
# ## and the losers...
# rounds |> 
#   filter(!win_series) |> 
#   summarize_b2b_round_wins(n_rounds)
```

![](b2b_round_win_prop.png){fig-align="center"}

## Is there evidence for the "hot hand"?

```{r}
#| label: round_win_prop_after_b2b2b_wins
## http://keyonvafa.com/hot-hand/
get_post_streak_prob <- function(n, k, p = 0.5) {
  tosses <- rbinom(n, 1, p)
  runs <- rle(tosses)
  n_neg_after <- length(which(runs$values == 1 & runs$lengths >= k))
  n_pos_after <- sum(runs$lengths[which(runs$values == 1 & runs$lengths >= k)] - k)
  
  ## edge case
  if (n %in% cumsum(runs$lengths)[which(runs$values == 1 & runs$lengths >= k)]) {
    n_neg_after <- n_neg_after - 1
  }
  
  n_pos_after / (n_pos_after + n_neg_after)
}

simulate_post_streak_prob <- function(sims = 1000, ...) {
  rerun(
    sims,
    get_post_streak_prob(...)
  ) |> 
    flatten_dbl() |> 
    mean(na.rm = TRUE)
}
# prob_n6_k2 <- simulate_post_streak_prob(sims = 10000, n = 6, k = 2, p = 0.5)
prob_n6_k3 <- simulate_post_streak_prob(sims = 10000, n = 6, k = 3, p = 0.5)
prob_n11_k3 <- simulate_post_streak_prob(sims = 10000, n = 8, k = 3, p = 0.5)
prob_n11_k3 <- simulate_post_streak_prob(sims = 10000, n = 11, k = 3, p = 0.5)
prob_n10_k1 <- simulate_post_streak_prob(sims = 10000, n = 10, k = 1, p = 0.5)

round_streaks <- rounds |> 
  # filter(round <= 6) |> 
  group_by(year, sheet, series, team) |> 
  mutate(
    won_prior_round2 = lag(win_round, n = 2, default = NA),
    won_prior_round3 = lag(win_round, n = 3, default = NA)
  ) |> 
  ungroup() |>
  select(
    year,
    sheet,
    series,
    team,
    is_offense,
    round,
    win_round,
    won_prior_round,
    won_prior_round2,
    won_prior_round3
  )

round_streaks_after_b2b2b <- round_streaks |> 
  filter(!is.na(won_prior_round2), !is.na(won_prior_round3)) |> 
  count(win_round, won_prior_round, won_prior_round2, won_prior_round3, sort = TRUE)

round_win_prop_after_b2b2b_wins <- round_streaks_after_b2b2b |> 
  filter(won_prior_round, won_prior_round2, won_prior_round3) |> 
  mutate(
    total = sum(n),
    prop = n / total
  ) |> 
  filter(win_round) |> 
  select(n, total, prop)
```

```{r}
#| label: round_win_prop_after_b2b2b_wins-eval
#| eval: true
prob_n6_k3 <- 0.3838163
round_win_prop_after_b2b2b_wins <- tibble(
  n = 352,
  total = 632
) |> 
  mutate(prop = n / total)
```

```{r}
#| label: summarize_and_compare_win_prop_after_wins
## https://content.iospress.com/articles/journal-of-sports-analytics/jsa200422#app2 suggests that we should look at non-overlapping streaks.
## "To avoid this problem, we examine only the frequency of winning game three after having won games one and two and the frequency of winning game six after having won games four and five". They sort of deduced that win %s > 50% in the third game might constitute momentum, but didn't make strong statements.
summarize_win_prop_after_x_wins <- function(round, ...) {
  round_streaks |> 
    filter(round == !!round) |> 
    count(win_round, won_prior_round, won_prior_round2, ..., sort = TRUE) |> 
    relocate(n) |> 
    drop_na(last_col()) |> 
    filter(won_prior_round, won_prior_round2, ...) |> 
    mutate(
      total = sum(n),
      prop = n / total
    ) |> 
    filter(win_round) |> 
    transmute(round = !!round, n, total, prop)
}

summarize_win_prop_after_b2b_wins <- summarize_win_prop_after_x_wins
summarize_win_prop_after_b2b2b_wins <- function(round) {
  summarize_win_prop_after_x_wins(round = round, won_prior_round3)
}

summarize_and_compare_win_prop_after_wins <- function(ri, add, f) {
  ra <- f(ri)
  rb <- f(ri + add)
  bind_rows(ra, rb)
}

summarize_and_compare_win_prop_after_b2b_wins <- partial(
  summarize_and_compare_win_prop_after_wins,
  add = 3,
  f = summarize_win_prop_after_b2b_wins,
  ... = 
)

summarize_and_compare_win_prop_after_b2b2b_wins <- partial(
  summarize_and_compare_win_prop_after_wins,
  add = 4,
  f = summarize_win_prop_after_b2b2b_wins,
  ... = 
)

win_prop_after_b2b_wins <- seq(3, 8, by = 1) |> 
  map_dfr(
    summarize_and_compare_win_prop_after_b2b_wins,
    .id = 'pair_idx'
  )

win_prop_after_b2b2b_wins <- seq(4, 7, by = 1) |> 
  map_dfr(
    summarize_and_compare_win_prop_after_b2b2b_wins,
    .id = 'pair_idx'
  )
```

<br/><br/>

-   Round win % after a streak of 3 round wins:
-   Expected: **`r 100 * round(prob_n6_k3, 3)`%**
-   Actual: **`r 100 * round(round_win_prop_after_b2b2b_wins$prop, 3)`%** (`r round_win_prop_after_b2b2b_wins$n` / `r round_win_prop_after_b2b2b_wins$total`)

::: notes
-   Note this is sort of biased by the fact that teams end up winning series in 6 rounds more often than expected.
:::

## Is planting at one site better than the other?

```{r}
#| label: plant_win_prop_proj
map_plant_win_prop <- rounds |> 
  filter(!is.na(plant)) |> 
  filter(is_offense) |> 
  group_by(year, game, map, plant) |> 
  summarize(
    n = n(),
    wins = sum(win_round)
  ) |> 
  ungroup() |> 
  mutate(
    win_prop = wins / n
  ) |> 
  group_by(year, game, map) |> 
  mutate(
    total = sum(n),
    rnk = row_number(-n),
    prop = n / total
  ) |> 
  ungroup()

plant_win_prop <- map_plant_win_prop |>
  mutate(site = ifelse(rnk == 1, 'pri', 'sec')) |> 
  group_by(site) |> 
  summarize(
    across(c(n, wins, total), sum)
  ) |> 
  ungroup() |> 
  mutate(
    win_prop = wins / n,
    prop = n / total
  )

plant_win_prop_proj <- plant_win_prop |> 
  left_join(
    rounds |> 
      filter(is_offense) |> 
      filter(is.na(plant)) |> 
      summarize(
        n_no_plant = n(),
        wins_no_plant = sum(win_round)
      ),
    by = character()
  ) |> 
  mutate(
    n_proj = round(n + prop * n_no_plant),
    wins_proj = round(wins + prop * wins_no_plant),
    win_prop_proj = wins_proj / n_proj
  )

plant_site_prop <- plant_win_prop_proj |> 
  select(site, prop) |> 
  deframe() |> 
  scales::percent(accuracy = 0.1)

plant_site_win_prop <- plant_win_prop_proj |> 
  select(site, win_prop_proj) |> 
  deframe() |> 
  scales::percent(accuracy = 0.1)
```

```{r}
#| label: plant_win_prop_proj-eval
#| eval: true
plant_site_prop <- c(
  'pri' = '60.9%',
  'sec' = '39.1%'
)
plant_site_win_prop <- c(
  'pri' = '47.4%',
  'sec' = '48.5%'
)
```

<br/><br/>

::: columns
::: {.column width="15%"}
:::

::: {.column .fragment width="30%"}
| Plant site |                           \% |
|------------|-----------------------------:|
| Primary    | `r plant_site_prop[['pri']]` |
| Secondary  | `r plant_site_prop[['sec']]` |
:::

::: {.column width="10%"}
:::

::: {.column .fragment width="30%"}
| Plant site |                            Win % |
|------------|---------------------------------:|
| Primary    | `r plant_site_win_prop[['pri']]` |
| Secondary  | `r plant_site_win_prop[['sec']]` |
:::

::: {.column width="15%"}
:::
:::

::: notes
-   Should you plant at most prevalent/winningest site? plant at other site? Go for kills?
:::
