---
title: "They're Clutching up! Team Momentum in Round-Based Esports"
execute: 
  include: false
  echo: false
  eval: false
format:
  arxiv-pdf:
    keep-tex: true  
  arxiv-html: default
author:
  - name: Tony ElHabr
    affiliations:
      - name: Georgia Institute of Technology
    email: anthonyelhabr@gmail.com
    url: https://tonyelhabr.rbind.io
abstract: |
  My research investigates patterns in round win percentages in professional Search and Destroy (SnD) matches of the popular first-person shooter game Call of Duty (CoD).

  First, I find evidence in CoD defying the naive hypothesis that a series represents a sequence of independent events (rounds), with each team having a constant 50% probability of winning a given round.
  
  Second, I examine post-streak round win probability. I find that teams perform significantly worse than expected after streaks of 2, 3, and 4 wins when series end up going to 9, 10, or 11 (maximum) rounds, even after accounting for the "hot-hand" phenomenon.
  
  Third, I compare win percentages in round one versus all other rounds, hypothesizing that there may be some advantage on either side when there is no prior information about how the opponent intends to play a given map in either game. I find only one instance for which there seems to be a significant defensive advantage in round one.
  
  Finally, I evaluate behavior when teams have two rounds left to win the series, observing a peak in COD offensive win percentages in the 4-4 state, and no such oddity in Valorant.
bibliography: references.bib  
---

```{r}
#| label: setup
#| eval: true
library(dplyr)
library(dplyr)
library(qs)
library(scales)

cod_rounds <- qs::qread('../cod_rounds.qs')
```

```{r}
#| label: setup-eval
library(tidyverse)
library(extrafont)
library(ggtext)
library(ggsci)
library(ggnewscale)
library(magick)
library(broom)
library(knitr)

background_color <- '#000000' ## to match slide background
text_color <- '#191919'

font <- 'Titillium Web'
extrafont::loadfonts(quiet = TRUE)
theme_set(theme_minimal())
theme_update(
  text = element_text(family = font),
  title = element_text(size = 14, color = text_color),
  plot.title = element_text(face = 'bold', size = 20, color = text_color),
  plot.title.position = 'plot',
  plot.subtitle = element_text(size = 14, color = '#f1f1f1'),
  axis.text = element_text(color = 'white', size = 14),
  axis.title = element_text(size = 14, color = text_color, face = 'bold', hjust = 0.99),
  axis.line = element_blank(),
  panel.grid.major = element_line(color = text_color),
  panel.grid.minor = element_line(color = text_color),
  panel.grid.minor.x = element_blank(),
  panel.grid.minor.y = element_blank(),
  strip.text = element_text(color = text_color, size = 16, face = 'bold'),
  plot.margin = margin(10, 10, 10, 10),
  plot.background = element_rect(fill = background_color, color = background_color),
  plot.caption = element_text(size = 12, color = text_color, hjust = 1),
  plot.caption.position = 'plot',
  plot.tag = ggtext::element_markdown(size = 12, color = text_color, hjust = 0),
  plot.tag.position = c(0.01, 0.01),
  panel.background = element_rect(fill = background, color = background_color)
)
update_geom_defaults('text', list(family = font, size = 10 / .pt, fontface = 'bold'))
update_geom_defaults('point', list(color = text_color))
update_geom_defaults('segment', list(color = text_color))
```

```{r}
#| label: descriptive-cod-snd-stats
#| eval: true
cod_n_series <- cod_rounds |> 
  distinct(series_id, team) |> 
  nrow()

cod_n_rounds <- cod_rounds |> 
  distinct(series_id, team, round) |> 
  nrow()
cod_n_rounds / cod_n_series
## mean(cod_rounds$n_rounds) ## should this be the same?

cod_o_win_prop_const <- cod_rounds |> 
  filter(is_offense) |> 
  count(win_round) |> 
  mutate(prop = n / sum(n)) |> 
  filter(win_round) |> 
  pull(prop)
```

```{r}
#| label: cod-funcs
common_cod_labs <- function(...) {
  list(
    ...,
    labs(
      caption = 'CDL SnD major and qualifier series, 2020 - 2022'
    )
  )
}

common_cod_heatmap_layers <- function(...) {
  list(
    ...,
    guides(
      fill = 'none'
    ),
    scale_x_continuous(
      labels = 0:5,
      breaks = seq(0.5, 5.5, by = 1),
      expand = c(0, 0)
    ),
    scale_y_continuous(
      labels = 0:5,
      breaks = seq(0.5, 5.5, by = 1),
      expand = c(0, 0),
      sec.axis = sec_axis(
        trans = I, 
        name = ' ', 
        breaks = seq(0.5, 5.5, by = 1), 
        labels = rep('', 6)
      )
    ),
    theme(
      panel.grid.major = element_blank(),
      axis.title = element_text(hjust = 0.5),
      plot.title = ggtext::element_markdown(hjust = 0.5),
      axis.text = element_text(size = 16, face = 'bold')
    ),
    common_cod_labs(),
    labs(
      x = "Offensive Team's # of Pre-Round Wins",
      y = "Defensive Team's # of Pre-Round Wins"
    )
  )
}

.dpi <- 300
save_plot_for_paper <- function(
    p, 
    filename = paste0(str_remove(deparse(substitute(p)), '^p_'), '.png'), 
    width = 7.5, 
    height = width / 1.5,
    units = 'px',
    dpi = .dpi,
    ...
) {
  
  path <- ggsave(
    plot = p,
    filename = file.path('plots', filename),
    width = width * dpi,
    height = height * dpi,
    units = units,
    dpi = dpi,
    ...
  )
  is_cod <- filename |> str_detect('cod_')
}

heatmap_tile <- function(..., .fill) {
  list(
    ...,
    geom_rect(
      color = background_color,
      aes(
        fill = .data[[.fill]],
        xmin = pre_cumu_w, 
        ymin = pre_cumu_l,
        xmax = pre_cumu_w + 1,
        ymax = pre_cumu_l + 1
      )
    )
  )
}


heatmap_text_layer <- function(..., .op, .df, .label, .num, .color, .threshold, .labeller, .size = 11 / .pt) {
  .df_filt <- .df |> filter(`.op`(.df[[.label]], .threshold))
  if(nrow(.df_filt) == 0) {
    return(list(...))
  }
  list(
    ...,
    geom_text(
      data = .df_filt,
      color = .color,
      size = .size,
      fontface = 'bold',
      aes(
        label = .labeller(.df = .df_filt, .label = .label, .num = .num),
        x = .data$pre_cumu_w + 0.5, 
        y = .data$pre_cumu_l + 0.5
      )
    )
  )
}

heatmap_text_layers <- function(
    ..., 
    .df,
    .threshold,
    .labeller,
    .f
) {
  list(
    ...,
    .f(.df = .df, .threshold = .threshold, .labeller = .labeller, .emphasize = 'low'),
    .f(.df = .df, .threshold = .threshold, .labeller = .labeller, .emphasize = 'high')
  )
}

cod_heatmap_seq_labeller <- function(.df, .label, .num) {
  sprintf(
    '%s\n(%s)',
    scales::percent(.df[[.label]], accuracy = 1), 
    scales::comma(.df$n)
  )
}


cod_heatmap_seq_labeller <- function(.df, .label, .num) {
  sprintf(
    '%s\n(%s)',
    scales::percent(.df[[.label]], accuracy = 1), 
    scales::comma(.df$n)
  )
}

o_round_win_text_layer <- function(
    ..., 
    .df,
    .threshold,
    .labeller,
    .label = 'win_round_prop',
    .num = 'win_round',
    .emphasize
) {
  if(.emphasize == 'low') {
    op <- `<`
    .color <- background_color
  } else {
    op <- `>=`
    .color <- 'white'
  }
  list(
    ...,
    heatmap_text_layer(
      .df = .df,
      .op = op,
      .label = .label,
      .num = .num,
      .color = .color,
      .threshold = .threshold,
      .labeller = .labeller,
      .size = 11 / .pt
    )
  )
}

cod_heatmap_div_labeller <- function(.df, .label, .num) {
  sprintf(
    '%+.1f\n(%s)', 
    100 * .df[[.label]], 
    scales::comma(.df$n)
  )
}

o_round_win_over_expected_text_layer <- function(
    ..., 
    .df, 
    .threshold,
    .labeller,
    .emphasize
) {
  if(.emphasize == 'low') {
    op <- `<`
    .color <- 'white'
  } else {
    op <- `>=`
    .color <- background_color
  }
  list(
    ...,
    heatmap_text_layer(
      .df = .df,
      .op = op,
      .label = 'diff_win_round_prop',
      .num = 1,
      .color = .color,
      .threshold = .threshold,
      .labeller = .labeller
    )
  )
}

extract_ggsci_mid_color <- function(palette) {
  ggsci::pal_material(palette, n = 3)(2)[2]
}

ggsci_purple <- extract_ggsci_mid_color('purple')
ggsci_green <- extract_ggsci_mid_color('green')
ggsci_cyan <- extract_ggsci_mid_color('cyan')
ggsci_brown <- extract_ggsci_mid_color('brown')
```

```{r}
#| label: cod_rounds-calcs
cod_round_and_series_win_prop_by_side <- cod_rounds |> 
  group_by(pre_cumu_w, pre_cumu_l, is_offense) |> 
  summarize(
    n = n(),
    across(c(win_round, win_series), sum)
  ) |> 
  ungroup() |> 
  mutate(
    win_round_prop = win_round / n,
    win_series_prop = win_series / n
  )

cod_e_o_win_series_prop <- crossing(
  pre_cumu_w = 0:5,
  pre_cumu_l = 0:5
) |> 
  mutate(
    n_remain_max = 11 - (pre_cumu_w + pre_cumu_l),
    n_remain_w = 6 - pre_cumu_w,
    ## can i account for offense in this by rotating?
    e_win_series_prop = map2_dbl(n_remain_w, n_remain_max, ~sum(dbinom(..1:..2, ..2, 0.5)))
  )
```

# 1. Introduction

## 1.1 Description of Call of Duty Search and Destroy

Call of Duty (CoD), first released in 2003, is one of the most popular first-person shooter (FPS) video game franchises of all-time. Tthe most popular mode in the competitive scene is "Search and Destroy" (SnD), which bears resemblance to "Bomb Defusal" in Counter-Strike and "Plant/Defuse" in Valorant, two other FPS games played in professional leagues. SnD is one-sided game mode in which one team, the offensive side, tries to destroy one of two designated bomb sites on the map.[^1]

[^1]: as

In professional CoD, a team must win six rounds of SnD to win the match.[^2] A round can end in one of four ways:

[^2]: A maximum of 11 even rounds can be played. There is no "sudden death" or "win by two" rule like there are for SnD equivalent in professional Counter-Strike and Valorant matches.

1.  One team eliminates all members of the other team prior to a bomb plant. (Eliminating team wins.)
2.  The offensive team eliminates all members of the defensive team after a bomb plant.[^3] (Offense wins.)
3.  The defensive team defuses the bomb after a bomb plant.[^4] (Defense wins.)
4.  The offensive team does not make a plant by the time the round timer ends. (Defense wins.)

[^3]:
    -   The bomb can be picked up by any member of the offensive team.
    -   The bomb carrier is not obstructed at all by carrying the bomb (i.e. movement is the same, weapon usage is the same).
    -   The defense does not get any visual indication for who is carrying the bomb.
    -   A bomb plant takes five seconds. The timer resets if the player stops planting site prior to completing it.
    -   A bomb defuse takes seven seconds. The timer resets if the player "drops" the bomb.
    -   The bomb takes 45 seconds to defuse after being planted.

[^4]: Often the defensive team will try to eliminate all team members prior to making the defuse, but in some cases, they may try to "ninja" defuse.

Teams take turns playing offense and defense every round.

## 1.2 Data

CoD has roughly gone through three eras of professional gaming: (1) Major League Gaming (MLG) tournaments prior to 2016; (2) the CoD World League (CWL), initiated in 2016; and (3) the 12-franchise CoD League (CDL), running since 2020 and completing three year-long "seasons" completed as of August 2022.[^5] The data set consists of all SnD matches played in tournaments and qualifiers during the CDL era. Data was collected in spreadsheets by community member "IOUTurtle".[^6]

[^5]: CoD is fairly unique compared to other esports in that it runs on an annual lifecycle (released coming in the late fall), where a new game is published every year under the same title. Each new game bears resemblance to past ones, often introducing relatively small variations ("improvements") to graphics, game modes, and other facets of gameplay. During the CDL era, the games released have been Modern Warfare (2020), Cold War (2021) and Vanguard (2022).

[^6]: Data: https://linktr.ee/CDLArchive. Author: https://twitter.com/IOUTurtle

I adopt the terminology "series" to refer to what CoD SnD players typically call a "match", so as to emulate the terminology of playoff series in professional leagues like the National Basketball Association, National Hockey League, and Major League Baseball. A "game" or a "match" in such leagues is analogous to a "round" of CoD SnD.

## 1.3 My contribution

# 2 Literature review

There have been only a handful of studies of the distribution of games played in a series, most of which assume a constant probability $p$ of a given team winning a game in the series, regardless of the series state. Observing that the American League had dominated the National League in Major League Baseball's (MLB) World Series matchups, implying that matchups should not modeled with $p=0.5$, [@mosteller1952] proposed three approaches for identifying the optimal constant probability value of the stronger team in the World Series, finding $p \approx 0.65$ in each case: (1) a "method of moments", an approach that solves for $p$ from the empirical average number of games won by the loser of the series; (2) maximum likelihood, and (3) maximum chi-square approach. [@chance2020] re-examines the constant probability notion in Major League Baseball's World Series (1923--2018), the National Basketball Association's Finals (1951--2018), and the National Hockey League's Stanley Cup (1939--2018). Chance applies Mosteller's method 1 and 2 and finds strong evidence against the null hypothesis of $p = 0.5$ in the MLB and NHL championship series. Chance outlines a conditional probability framework (likelihood of winning a game given the series state) which can exactly explain the distribution of the number of games played.

Momentum is one of the most frequently published topics in sports analytics. We often use use "streaks" and momentum interchangeably, but as [@steeger2021] note, momentum implies dependence between events, whereas streaking does not. (sentence about negative recency, hinting at "hot hand"... [@miller2018] debunking findings from [@gilovich1985])

Despite the plethora of existing research on games played and momentum in sports, these topics have yet to be investigated heavily in esports. Work has been done to examine in-round win probability in other FPS titles such as Counter-Strike ([@xenopoulos2022]) and Valorant ([@derover2021]), both of which are round-based like CoD SnD. However, research on round-level trends is sparse, perhaps because games like Counter-Strike and Valorant both have economic aspects that can create clear advantages on side in a given round, given how prior rounds played out.[^7]\[\^8\]

[^7]: Additionally, both Counter-Strike and Valorant have overtime rules and blocked offensive/defensive roles (i.e. playing either offense or defense for many consecutive rounds).

# 3. Methodology

# 4. Results and discussion

# References {.unnumbered}

::: {#refs}
:::
