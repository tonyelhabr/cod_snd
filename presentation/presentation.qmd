---
title: "They're Clutching up! Team Momentum in Round-Based Esports"
author: 'Tony ElHabr'
format:
  revealjs:
    slide-number: true
    incremental: false
    theme: [dark, theme.scss]
execute: 
  include: false
  echo: false
  eval: false
---

```{r}
#| label: setup
#| eval: true
library(dplyr)
library(dplyr)
library(qs)
library(scales)

cod_rounds <- qs::qread('../data/cod_rounds.qs')
```

```{r}
#| label: setup-eval
library(tidyverse)
library(extrafont)
library(ggtext)
library(ggsci)
library(ggnewscale)
library(magick)
library(broom)
library(knitr)

blackish_background <- '#191919' ## to match slide background
gray_points <- '#4d4d4d'
gray_text <- '#999999'

font <- 'Titillium Web'
extrafont::loadfonts(quiet = TRUE)
theme_set(theme_minimal())
theme_update(
  text = element_text(family = font),
  title = element_text(size = 14, color = 'white'),
  plot.title = element_text(face = 'bold', size = 20, color = 'white'),
  plot.title.position = 'plot',
  plot.subtitle = element_text(size = 14, color = '#f1f1f1'),
  axis.text = element_text(color = 'white', size = 14),
  axis.title = element_text(size = 14, color = 'white', face = 'bold', hjust = 0.99),
  axis.line = element_blank(),
  panel.grid.major = element_line(color = gray_points),
  panel.grid.minor = element_line(color = gray_points),
  panel.grid.minor.x = element_blank(),
  panel.grid.minor.y = element_blank(),
  strip.text = element_text(color = 'white', size = 16, face = 'bold'),
  plot.margin = margin(10, 10, 10, 10),
  plot.background = element_rect(fill = blackish_background, color = blackish_background),
  plot.caption = element_text(size = 12, color = 'white', hjust = 1),
  plot.caption.position = 'plot',
  plot.tag = ggtext::element_markdown(size = 12, color = 'white', hjust = 0),
  plot.tag.position = c(0.01, 0.01),
  panel.background = element_rect(fill = blackish_background, color = blackish_background)
)
update_geom_defaults('text', list(family = font, size = 10 / .pt, fontface = 'bold'))
update_geom_defaults('point', list(color = 'white'))
update_geom_defaults('segment', list(color = 'white'))
```

## Search and Destroy (SnD) in Call of Duty (CoD)

::: fragment
-   2020-2022 Call of Duty League (CDL) matches (qualifiers and majors)
-   4v4
-   First to 6 round wins
-   Teams swap sides (offense and defense) after every round
:::

## How does a team win a round of CoD SnD ?

::: fragment
1.  One team eliminates all members of the other team prior to a bomb plant.
:::

::: fragment
2.  The offensive team eliminates all members of the defensive team after a bomb plant.
:::

::: fragment
3.  The defensive team defuses the bomb after a bomb plant.
:::

::: fragment
Often the defensive team will try to eliminate all team members prior to making the defuse, but in some cases, they may try to "ninja" defuse.
:::

::: fragment
4.  The offensive team does not make a plant by the time the round timer ends.
:::

## CoD SnD data overview

```{r}
#| label: descriptive-cod-snd-stats
#| eval: true
cod_n_series <- cod_rounds |> 
  distinct(series_id, team) |> 
  nrow() |> 
  scales::comma()

cod_n_rounds <- cod_rounds |> 
  distinct(series_id, team, round) |> 
  nrow() |> 
  scales::comma()

cod_o_win_prop_const <- cod_rounds |> 
  filter(is_offense) |> 
  count(win_round) |> 
  mutate(prop = n / sum(n)) |> 
  filter(win_round) |> 
  pull(prop)
cod_o_win_pct <- scales::percent(cod_o_win_prop_const, accuracy = 0.1)

cod_rounds |> 
  filter(is_offense) |> 
  count(game, win_round) |> 
  group_by(game) |> 
  mutate(prop = n / sum(n)) |> 
  ungroup() |> 
  filter(win_round)

cod_plant_pct <- cod_rounds |>
  filter(is_offense) |> 
  count(makes_plant = !is.na(plant)) |> 
  mutate(prop = n / sum(n)) |> 
  filter(makes_plant) |> 
  pull(prop) |> 
  scales::percent(accuracy = 0.1)

cod_o_plant_and_win_pct <- cod_rounds |> 
  filter(is_offense, !is.na(plant)) |> 
  count(win_round) |> 
  mutate(prop = n / sum(n)) |> 
  filter(win_round) |> 
  pull(prop) |> 
  scales::percent(accuracy = 0.1)

cod_o_first_blood_win_pct <- cod_rounds |> 
  filter(!is.na(earned_fb)) |> 
  filter(earned_fb) |> 
  count(win_round) |> 
  mutate(prop = n / sum(n)) |> 
  filter(win_round) |> 
  pull(prop) |> 
  scales::percent(accuracy = 0.1)
```

::: fragment
-   Total series: **`r cod_n_series`**
:::

::: fragment
-   Total rounds: **`r cod_n_rounds`**
:::

::: fragment
-   Offensive plant %: **`r cod_plant_pct`**
:::

::: fragment
-   Offensive win %: **`r cod_o_win_pct`**
:::

::: fragment
-   Win % when planting: **`r cod_o_plant_and_win_pct`**
:::

::: fragment
-   Win % when earning first blood: **`r cod_o_first_blood_win_pct`**
:::

## What are your chances of winning the next round?

```{r}
#| label: cod-funcs
common_cod_labs <- function(...) {
  list(
    ...,
    labs(
      caption = 'CDL SnD major and qualifier series, 2020 - 2022'
    )
  )
}

common_cod_heatmap_layers <- function(...) {
  list(
    ...,
    guides(
      fill = 'none'
    ),
    scale_x_continuous(
      labels = 0:5,
      breaks = seq(0.5, 5.5, by = 1),
      expand = c(0, 0)
    ),
    scale_y_continuous(
      labels = 0:5,
      breaks = seq(0.5, 5.5, by = 1),
      expand = c(0, 0),
      sec.axis = sec_axis(
        trans = I, 
        name = ' ', 
        breaks = seq(0.5, 5.5, by = 1), 
        labels = rep('', 6)
      )
    ),
    theme(
      panel.grid.major = element_blank(),
      axis.title = element_text(hjust = 0.5),
      plot.title = ggtext::element_markdown(hjust = 0.5),
      axis.text = element_text(size = 16, face = 'bold')
    ),
    common_cod_labs(),
    labs(
      x = "Offensive Team's # of Pre-Round Wins",
      y = "Defensive Team's # of Pre-Round Wins"
    )
  )
}

.dpi <- 300
save_plot_for_slide <- function(
    p, 
    filename = paste0(str_remove(deparse(substitute(p)), '^p_'), '.png'), 
    width = 7.5, 
    height = width / 1.5,
    units = 'px',
    dpi = .dpi,
    ...
) {
  
  ggsave(
    plot = p,
    filename = file.path('plots', filename),
    width = width * dpi,
    height = height * dpi,
    units = units,
    dpi = dpi,
    ...
  )
}

heatmap_tile <- function(..., .fill) {
  list(
    ...,
    geom_rect(
      color = blackish_background,
      aes(
        fill = .data[[.fill]],
        xmin = pre_cumu_w, 
        ymin = pre_cumu_l,
        xmax = pre_cumu_w + 1,
        ymax = pre_cumu_l + 1
      )
    )
  )
}

heatmap_text_layer <- function(..., .op, .df, .label, .num, .color, .threshold, .labeller, .size = 11 / .pt) {
  .df_filt <- .df |> filter(`.op`(.df[[.label]], .threshold))
  if(nrow(.df_filt) == 0) {
    return(list(...))
  }
  list(
    ...,
    geom_text(
      data = .df_filt,
      color = .color,
      size = .size,
      fontface = 'bold',
      aes(
        label = .labeller(.df = .df_filt, .label = .label, .num = .num),
        x = .data$pre_cumu_w + 0.5, 
        y = .data$pre_cumu_l + 0.5
      )
    )
  )
}

heatmap_text_layers <- function(
    ..., 
    .df,
    .threshold,
    .labeller,
    .f
) {
  list(
    ...,
    .f(.df = .df, .threshold = .threshold, .labeller = .labeller, .emphasize = 'low'),
    .f(.df = .df, .threshold = .threshold, .labeller = .labeller, .emphasize = 'high')
  )
}

cod_heatmap_seq_labeller <- function(.df, .label, .num) {
  sprintf(
    '%s\n(%s)',
    scales::percent(.df[[.label]], accuracy = 0.1), 
    scales::comma(.df$n)
  )
}

o_round_win_text_layer <- function(
    ..., 
    .df,
    .threshold,
    .labeller,
    .label = 'win_round_prop',
    .num = 'win_round',
    .emphasize
) {
  if(.emphasize == 'low') {
    op <- `<`
    .color <- blackish_background
  } else {
    op <- `>=`
    .color <- 'white'
  }
  list(
    ...,
    heatmap_text_layer(
      .df = .df,
      .op = op,
      .label = .label,
      .num = .num,
      .color = .color,
      .threshold = .threshold,
      .labeller = .labeller,
      .size = 11 / .pt
    )
  )
}
o_series_win_text_layer <- function(
    ..., 
    .df,
    .threshold,
    .labeller, 
    .emphasize
) {
  if(.emphasize == 'low') {
    op <- `<`
    .color <- blackish_background
  } else {
    op <- `>=`
    .color <- 'white'
  }
  list(
    ...,
    heatmap_text_layer(
      .df = .df,
      .op = op,
      .label = 'win_series_prop',
      .num = 'win_series',
      .color = .color,
      .threshold = .threshold,
      .labeller = .labeller,
      .size = 9 / .pt
    )
  )
}
cod_heatmap_div_labeller <- function(.df, .label, .num) {
  sprintf(
    '%+.1f\n(%s)', 
    100 * .df[[.label]], 
    scales::comma(.df$n)
  )
}

o_round_win_over_expected_text_layer <- function(
    ..., 
    .df, 
    .threshold,
    .labeller,
    .emphasize
) {
  if(.emphasize == 'low') {
    op <- `<`
    .color <- 'white'
  } else {
    op <- `>=`
    .color <- blackish_background
  }
  list(
    ...,
    heatmap_text_layer(
      .df = .df,
      .op = op,
      .label = 'diff_win_round_prop',
      .num = 1,
      .color = .color,
      .threshold = .threshold,
      .labeller = .labeller
    )
  )
}

o_series_win_over_expected_text_layer <- function(
    ..., 
    .df,
    .threshold,
    .labeller, 
    .emphasize
) {
  if(.emphasize == 'low') {
    op <- `<`
    .color <- blackish_background
  } else {
    op <- `>=`
    .color <- 'white'
  }
  list(
    ...,
    heatmap_text_layer(
      .df = .df,
      .op = op,
      .label = 'diff_win_series_prop',
      .num = NULL,
      .color = .color,
      .threshold = .threshold,
      .labeller = .labeller,
      .size = 9 / .pt
    )
  )
}

extract_ggsci_mid_color <- function(palette) {
  ggsci::pal_material(palette, n = 3)(2)[2]
}

ggsci_purple <- extract_ggsci_mid_color('purple')
ggsci_green <- extract_ggsci_mid_color('green')
ggsci_cyan <- extract_ggsci_mid_color('cyan')
ggsci_brown <- extract_ggsci_mid_color('brown')
```

```{r}
#| label: cod_rounds-calcs
cod_round_and_series_win_prop_by_side <- cod_rounds |> 
  group_by(pre_cumu_w, pre_cumu_l, is_offense) |> 
  summarize(
    n = n(),
    across(c(win_round, win_series), sum)
  ) |> 
  ungroup() |> 
  mutate(
    win_round_prop = win_round / n,
    win_series_prop = win_series / n
  )

cod_e_o_win_series_prop <- crossing(
  pre_cumu_w = 0:5,
  pre_cumu_l = 0:5
) |> 
  mutate(
    n_remain_max = 11 - (pre_cumu_w + pre_cumu_l),
    n_remain_w = 6 - pre_cumu_w,
    ## can i account for offense in this by rotating?
    e_win_series_prop = map2_dbl(n_remain_w, n_remain_max, ~sum(dbinom(..1:..2, ..2, 0.5)))
  )

cod_o_win_prop <- cod_round_and_series_win_prop_by_side |> 
  filter(is_offense) |> 
  mutate(
    diff_win_round_prop = win_round_prop - !!cod_o_win_prop_const
  ) |> 
  inner_join(
    cod_e_o_win_series_prop |> select(pre_cumu_w, pre_cumu_l, e_win_series_prop),
    by = c('pre_cumu_w', 'pre_cumu_l')
  ) |> 
  mutate(
    diff_win_series_prop = win_series_prop - e_win_series_prop
  )
```

```{r}
#| label: p_cod_o_round_win_prop
p_cod_o_round_win_prop <- cod_o_win_prop |> 
  ggplot() +
  common_cod_heatmap_layers() +
  heatmap_tile(.fill = 'win_round_prop') +
  heatmap_text_layers(
    .df = cod_o_win_prop,
    .f = o_round_win_text_layer,
    .threshold = 0.52,
    .labeller = cod_heatmap_seq_labeller
  ) +
  ggsci::scale_fill_material('teal') +
  labs(
    title = 'Offensive Round Win %'
  )
p_cod_o_round_win_prop
save_plot_for_slide(p_cod_o_round_win_prop)
```

![](plots/cod_o_round_win_prop.png){fig-align="center"}

## What are your chances of winning the next round?

```{r}
#| label: p_cod_o_round_win_prop_over_expected
cod_max_diff_win_round_prop <- max(abs(cod_o_win_prop$diff_win_round_prop))
p_cod_o_round_win_prop_over_expected <- cod_o_win_prop |> 
  ggplot() +
  common_cod_heatmap_layers() +
  heatmap_tile(.fill = 'diff_win_round_prop') +
  heatmap_text_layers(
    .df = cod_o_win_prop, 
    .f = o_round_win_over_expected_text_layer,
    .threshold = -0.1,
    .labeller = cod_heatmap_div_labeller
  ) +
  scale_fill_gradient2(
    low = ggsci_purple,
    high = ggsci_green,
    mid = 'white',
    midpoint = 0,
    limits = c(
      -cod_max_diff_win_round_prop, 
      +cod_max_diff_win_round_prop
    )
  ) +
  labs(
    title = 'Offensive Round Win % Over Expected'
  )
p_cod_o_round_win_prop_over_expected
save_plot_for_slide(p_cod_o_round_win_prop_over_expected)
```

![](plots/cod_o_round_win_prop_over_expected.png){fig-align="center"}

## What are your chances of winning the series?

```{r}
#| label: p_cod_o_series_win_prop
p_cod_o_series_win_prop <- cod_o_win_prop |> 
  ggplot() +
  common_cod_heatmap_layers() +
  heatmap_tile(.fill = 'win_series_prop') +
  heatmap_text_layers(
    .df = cod_o_win_prop, 
    .f = o_series_win_text_layer,
    .threshold = 0.8,
    .labeller = cod_heatmap_seq_labeller
  ) +
  ggsci::scale_fill_material('orange') +
  labs(
    title = 'Offensive Series Win %'
  )
p_cod_o_series_win_prop
save_plot_for_slide(p_cod_o_series_win_prop)
```

![](plots/cod_o_series_win_prop.png){fig-align="center"}

## What are your chances of winning the series?

```{r}
#| label: p_cod_o_series_win_prop_over_expected
cod_max_diff_win_series_prop <- max(abs(cod_o_win_prop$diff_win_series_prop))
p_cod_o_series_win_prop_over_expected <- cod_o_win_prop |> 
  ggplot() +
  common_cod_heatmap_layers() +
  heatmap_tile(
    .fill = 'diff_win_series_prop'
  ) +
  heatmap_text_layers(
    .df = cod_o_win_prop, 
    .f = o_series_win_over_expected_text_layer,
    .threshold = 0.08,
    .labeller = cod_heatmap_div_labeller
  ) +
  scale_fill_gradient2(
    low = ggsci_brown,
    high = ggsci_cyan,
    mid = 'white',
    midpoint = 0,
    limits = c(
      -cod_max_diff_win_series_prop, 
      +cod_max_diff_win_series_prop
    )
  ) +
  labs(
    title = 'Offensive Series Win % Over Expected'
  )
p_cod_o_series_win_prop_over_expected
save_plot_for_slide(p_cod_o_series_win_prop_over_expected)
```

![](plots/cod_o_series_win_prop_over_expected.png){fig-align="center"}

## What are the most common series winning states?

```{r}
#| label: p_cod_series_outcome_prop_over_expected
# https://content.iospress.com/articles/journal-of-sports-analytics/jsa200422
prob_of_series_lasting_n_games <- function(n, p = 0.5, max_round) {
  s <- ceiling(max_round / 2)
  (factorial(n - 1) / (factorial(s - 1) * factorial(n - s))) * (p^s * (1 - p)^(n - s) + p^(n - s) * (1 - p)^s)
}

expected_series_streaks_of_outcomes <- function(m, n) {
  factorial(m + n) / (factorial(m) * factorial(n))
}

# https://raw.githubusercontent.com/dgrtwo/splittestr/master/R/vectorized-prop-test.R
vectorized_prop_test_approx <- function(a, b, c, d) {
  n1 <- a + b
  n2 <- c + d
  n <- n1 + n2
  p <- (a + c) / n
  E <- cbind(p * n1, (1 - p) * n1, p * n2, (1 - p) * n2)
  
  x <- cbind(a, b, c, d)
  
  DELTA <- a / n1 - c / n2
  YATES <- pmin(.5, abs(DELTA) / sum(1 / n1 + 1 / n2))
  
  STATISTIC <- rowSums((abs(x - E) - YATES)^2 / E)
  PVAL <- pchisq(STATISTIC, 1, lower.tail = FALSE)
  PVAL
}

vectorized_prop_test_exact <- function(a, b, c, d) {
  sapply(seq_along(a), function(i) {
    fisher.test(cbind(c(a[i], c[i]), c(b[i], d[i])))$p.value
  })
}

vectorized_prop_test <- function(x1, n1, x2, n2, conf.level = .95) {
  a <- x1
  b <- n1 - x1
  c <- x2
  d <- n2 - x2
  
  # if any values are < 20, use Fisher's exact test
  exact <- (a < 20 | b < 20 | c < 20 | d < 20)
  
  pvalue <- rep(NA, length(a))
  
  if (any(exact)) {
    pvalue[exact] <- vectorized_prop_test_exact(a[exact], b[exact], c[exact], d[exact])
  }
  if (any(!exact)) {
    pvalue[!exact] <- vectorized_prop_test_approx(a[!exact], b[!exact], c[!exact], d[!exact])
  }
  
  mu1 <- a / (a + b)
  mu2 <- c / (c + d)
  
  ## confidence interval
  alpha2 <- (1 - conf.level) / 2
  DELTA <- mu2 - mu1
  WIDTH <- qnorm(alpha2)
  alpha <- (a + .5) / (a + b + 1)
  beta <- (c + .5) / (c + d + 1)
  
  n <- n1 + n2
  YATES <- pmin(.5, abs(DELTA) / sum(1 / n1 + 1 / n2))
  
  z <- qnorm((1 + conf.level) / 2)
  WIDTH <- z * sqrt(mu1 * (1 - mu1) / n1 + mu2 * (1 - mu2) / n2)
  
  tibble(
    estimate = DELTA,
    conf.low = pmax(DELTA - WIDTH, -1),
    conf.high = pmin(DELTA + WIDTH, 1),
    p.value = pvalue
  )
}

summarize_round_arrangements <- function(rounds, .max_round, .adj = 0) {
  rounds |> 
    filter(round <= (.max_round - .adj)) |> 
    filter(win_series) |> 
    mutate(across(win_round, as.integer)) |> 
    group_by(series_id) |> 
    summarize(
      wins = max(cumu_w),
      losses = max(cumu_l),
      ws = paste0(win_round, collapse = '-')
    ) |> 
    ungroup() |> 
    mutate(n_rounds = wins + losses) |> 
    unite(
      record, wins, losses, sep = '-'
    ) |>
    count(record, n_rounds, ws, sort = TRUE) |> 
    mutate(prop = n / sum(n))
}

summarize_cod_round_arrangements <- partial(
  summarize_round_arrangements,
  .max_round = 11,
  .adj = 0
)

summarize_streaks <- function(rounds) {
  .max_round <- 11
  .adj <- 0
  
  cutoff <- (.max_round + 1) / 2
  
  actual_round_streaks <- rounds |> 
    summarize_round_arrangements(.max_round = .max_round, .adj = .adj)
  
  expected_round_streaks <- tibble(
    n_rounds = cutoff:.max_round
  ) |> 
    mutate(
      series_prop = map_dbl(n_rounds, ~prob_of_series_lasting_n_games(.x, max_round = .max_round)),
      n_expected_series_streaks = map2_dbl(cutoff, n_rounds - cutoff, expected_series_streaks_of_outcomes)
    ) |> 
    transmute(
      n_rounds,
      series_prop,
      prop = series_prop / n_expected_series_streaks
    )
  
  round_streaks <- full_join(
    actual_round_streaks |> 
      rename_with(~sprintf('%s_actual', .x), c(n, prop)),
    expected_round_streaks |> 
      rename_with(~sprintf('%s_expected', .x), prop),
    by = 'n_rounds'
  )
  
  round_streak_prop <- round_streaks |> 
    drop_na() |> 
    mutate(
      prop_diff = prop_actual - prop_expected,
      total_actual = sum(n_actual),
      n_expected = round(prop_expected * total_actual),
      p = vectorized_prop_test(n_actual, total_actual, n_expected, total_actual)
    ) |> 
    select(-total_actual) |> 
    unnest_wider(p) |> 
    arrange(p.value)
  
  series_outcomes <- full_join(
    actual_round_streaks |> 
      group_by(record, n_rounds) |> 
      summarize(
        across(n, sum)
      ) |> 
      ungroup() |> 
      mutate(prop = n / sum(n)) |> 
      rename_with(~sprintf('%s_actual', .x), c(n, prop)),
    expected_round_streaks |> 
      select(n_rounds, prop_expected = series_prop),
    by = 'n_rounds'
  )
  
  series_outcome_prop <- series_outcomes |> 
    drop_na() |> 
    mutate(
      prop_diff = prop_actual - prop_expected,
      total_actual = sum(n_actual),
      n_expected = round(prop_expected * total_actual),
      p = vectorized_prop_test(n_actual, total_actual, n_expected, total_actual)
    ) |> 
    select(-total_actual) |> 
    unnest_wider(p) |> 
    arrange(p.value)
  
  list(
    rounds = round_streak_prop,
    series = series_outcome_prop
  )
}

plot_series_outcome_prop_over_expected <- function(series_outcome_prop) {
  .lvls <- sprintf('6-%d', 0:5)
  .axis_x_text_size <- 14
  
  long_series_outcome_prop <- series_outcome_prop |>
    select(
      record,
      n = n_actual,
      `3` = prop_actual,
      `2` = prop_expected,
      `1` = prop_diff
    ) |> 
    pivot_longer(
      matches('[123]'),
      names_to = 'outcome_idx',
      values_to = 'value'
    ) |> 
    mutate(
      across(outcome_idx, as.integer),
      across(record, ~factor(.x, levels = .lvls))
    )
  
  max_diff_series_outcome_prop <- long_series_outcome_prop |> 
    filter(outcome_idx == 1) |> 
    pull(value) |> 
    abs() |> 
    max()
  
  long_series_outcome_prop |> 
    ggplot() +
    aes(x = record, y = outcome_idx) +
    geom_tile(
      data = long_series_outcome_prop |> filter(outcome_idx > 1),
      show.legend = FALSE,
      # height = 0.8,
      aes(fill = value)
    ) +
    ggsci::scale_fill_material(
      palette = 'light-blue'
    ) +
    ggnewscale::new_scale_fill() +
    geom_tile(
      data = long_series_outcome_prop |> filter(outcome_idx == 1),
      show.legend = FALSE,
      height = 0.8,
      aes(fill = value)
    ) +
    scale_fill_gradient2(
      low = extract_ggsci_mid_color('purple'),
      high = extract_ggsci_mid_color('green'),
      mid = 'white',
      midpoint = 0,
      limits = c(
        -max_diff_series_outcome_prop, 
        +max_diff_series_outcome_prop
      )
    ) +
    geom_text(
      data = long_series_outcome_prop |> filter(outcome_idx == 3),
      color = blackish_background,
      size = 11 / .pt,
      aes(label = sprintf('%.1f%%\n(%s)', 100 * value, scales::comma(n)))
    ) +
    geom_text(
      data = long_series_outcome_prop |> filter(outcome_idx == 2),
      color = blackish_background,
      size = 11 / .pt,
      aes(label = sprintf('%.1f%%', 100 * value))
    ) +
    geom_text(
      data = long_series_outcome_prop |> filter(outcome_idx == 1) |> filter(abs(value) != max(abs(value))),
      color = blackish_background,
      size = 11 / .pt,
      aes(label = sprintf('%+.1f%%', 100 * value))
    ) +
    geom_text(
      data = long_series_outcome_prop |> filter(outcome_idx == 1) |> filter(abs(value) == max(abs(value))),
      color = 'white',
      size = 11 / .pt,
      aes(label = sprintf('%+.1f%%', 100 * value))
    ) +
    scale_x_discrete(
      position = 'top',
      expand = c(0, 0)
    ) +
    scale_y_continuous(
      labels = c('Diff.', 'Expected', 'Actual'),
      breaks = 1:3,
      expand = c(0, 0)
    ) +
    theme(
      panel.grid.major = element_blank(),
      axis.title = element_text(hjust = 0.5),
      plot.title = ggtext::element_markdown(hjust = 0.5),
      axis.text = element_text(size = 14, face = 'bold'),
      axis.text.x = element_text(size = .axis_x_text_size, face = 'bold')
    ) +
    labs(
      title = 'Series outcome %',
      x = NULL,
      y = NULL
    )
}

cod_streaks_res <- cod_rounds |> summarize_streaks()

p_cod_series_outcome_prop_over_expected <- cod_streaks_res$series |> 
  plot_series_outcome_prop_over_expected() +
  common_cod_labs()
p_cod_series_outcome_prop_over_expected
save_plot_for_slide(p_cod_series_outcome_prop_over_expected)
```

![](plots/cod_series_outcome_prop_over_expected.png){fig-align="center"}

## Should round win percentage be modeled as constant?

::: fragment
[Chance (2019)](https://content.iospress.com/articles/journal-of-sports-analytics/jsa200422) finds that the probability of winning a game in the title series in the MLB and NHL is **not** constant (at 50%)
:::

```{r}
#| label: cod_streak_series
cod_streaks_res$series |> 
  arrange(n_rounds) |> 
  transmute(
    `# of rounds (i)` = n_rounds, 
    `P(i)` = scales::percent(prop_expected, accuracy = 0.1)
  ) |> 
  knitr::kable()

cod_streaks_res$series |> 
  select(
    n_rounds,
    prop_expected,
    prop_actual,
    n_actual
  ) |> 
  arrange(n_rounds) |> 
  gt::gt() |> 
  gt::cols_label(
    n_rounds = '# of rounds (i)', 
    prop_expected = 'P(i)',
    prop_actual = '%',
    n_actual = 'N'
  ) |> 
  gt::fmt_percent(
    decimals = 1,
    columns = c('prop_expected', 'prop_actual')
  ) |> 
  gt::cols_align(
    align = 'right',
    columns = c('prop_expected', 'prop_actual')
  ) |> 
  gt::tab_spanner(
    label = 'Observed',
    columns = c('prop_actual', 'n_actual')
  ) |> 
  gt::as_latex() |> 
  pluck(1)
```

```{r}
#| label: chance-2019
chance_2019_leagues <- c('MLB World Series', 'NBA Finals', 'NHL Stanley Cup')

n_sports <- tibble(
  league = chance_2019_leagues,
  ## i think nba has to be 2019 instead of 2018 in order for the product of `n * prop_actual` to be a whole number
  n = c(2018 - 1923, 2019 - 1951, 2018 - 1939)
)

chance_sports <- tibble(
  league = rep(chance_2019_leagues, each = 4),
  games = rep(4:7, 3),
  prop_actual = c(
    c(0.1895, 0.2105, 0.2105, 0.3895),
    c(0.1324, 0.25, 0.3382, 0.2794),
    c(0.2532, 0.2278, 0.3165, 0.2025)
  ),
  prop_expected = rep(c(0.125, 0.25, 0.3125, 0.3125), 3)
)

sports <- chance_sports |> 
  inner_join(
    n_sports,
    by = 'league'
  ) |> 
  mutate(
    n_actual = round(n * prop_actual)
  )

generate_chi_label <- function(statistic, p.value) {
  sprintf('%.1f (%s)', statistic, ifelse(p.value <= 0.01, '<=0.01', as.character(round(p.value, 2))))
}

chi_sports <- sports |> 
  nest(data = -c(league)) |> 
  mutate(
    chi = map(data, ~chisq.test(.x$n_actual, p = .x$prop_expected) |> broom::tidy())
  ) |> 
  select(league, chi) |> 
  unnest(chi) |> 
  transmute(
    league, 
    label = generate_chi_label(statistic, p.value)
  )

sports |> 
  select(league, games, prop_expected, prop_actual) |> 
  mutate(
    across(
      starts_with('prop_'),
      scales::percent
    ),
    across(games, as.character)
  ) |> 
  pivot_wider(names_from = league, values_from = prop_actual) |> 
  bind_rows(
    bind_cols(
      tibble(games = 'Avg. # of games'),
      sports |> 
        distinct(games, prop_expected) |>
        summarize(prop_expected = as.character(round(sum(games * prop_expected), 2))),
      sports |> 
        group_by(league) |>
        summarize(z = as.character(round(sum(games * prop_actual), 2))) |> 
        pivot_wider(names_from = league, values_from = z)
    )
  ) |> 
  bind_rows(
    chi_sports |> 
      pivot_wider(names_from = league, values_from = label) |> 
      mutate(
        games = '$\\xi^2$ (p-value)'
      )
  ) |> 
  relocate(
    `Series ends in i games` = games,
    `Expected` = prop_expected
  ) |> 
  knitr::kable()
```

::: fragment
|         Series length | Expected | MLB World Series | NBA Finals | NHL Stanley Cup |
|----------------------:|---------:|-----------------:|-----------:|----------------:|
|                     4 |   12.50% |           18.95% |     13.24% |          25.32% |
|                     5 |   25.00% |           21.05% |     25.00% |          22.78% |
|                     6 |   31.25% |           21.05% |     33.82% |          31.65% |
|                     7 |   31.25% |           38.95% |     27.94% |          20.25% |
|                       |          |                  |            |                 |
|  **Avg. \# of games** |     5.81 |              5.8 |       5.76 |            5.47 |
| $\xi^2$ **(p-value)** |          |       8.7 (0.03) | 0.4 (0.94) |  13.6 (\<=0.01) |
:::

```{r}
#| label: cod_series_outcomes_chi
cod_rounds_per_series <- cod_streaks_res$series |>
  summarize(
    actual = sum(n_rounds * prop_actual),
    expected = sum(n_rounds * prop_expected)
  )
avg_actual_cod_rounds_per_series <- round(cod_rounds_per_series$actual, 2)
avg_expected_cod_rounds_per_series <- round(cod_rounds_per_series$expected, 2)

cod_series_outcomes_chi <- chisq.test(
  cod_streaks_res$series$n_actual, 
  p = cod_streaks_res$series$prop_expected
) |> 
  broom::tidy() |> 
  mutate(label = generate_chi_label(statistic, p.value)) |> 
  pull(label)
cod_series_outcomes_chi
```

```{r}
#| label: cod_series_outcomes_chi-eval
#| eval: true
avg_actual_cod_rounds_per_series <- 9.15
avg_expected_cod_rounds_per_series <- 9.29
cod_series_outcomes_chi <- '16.0 (<=0.01)'
```

::: fragment
-   In CoD, the average number of rounds (**`r avg_actual_cod_rounds_per_series`**) is less than the expected value (**`r avg_expected_cod_rounds_per_series`**)
:::

::: fragment
-   A $\xi^2$ test for CoD demonstrates evidence against the constant probability null hypothesis for winning a given round in an SnD series (**`r cod_series_outcomes_chi`**)
:::

## Should round win percentage be modeled as constant?

```{r}
#| label: alternative-to-p=0.5-method-1
## p. 365 on https://math.mit.edu/classes/18.095/2016IAP/lec9/Sports_Mosteller1952_WorldSeries.pdf
theoretical_cod_series_length <- function(p) {
  6 * prob_of_series_lasting_n_games(n = 6, p = p, max_round = 11) +
    7 * prob_of_series_lasting_n_games(n = 7, p = p, max_round = 11) + 
    8 * prob_of_series_lasting_n_games(n = 8, p = p, max_round = 11) + 
    9 * prob_of_series_lasting_n_games(n = 9, p = p, max_round = 11) +
    10 * prob_of_series_lasting_n_games(n = 10, p = p, max_round = 11) +
    11 * prob_of_series_lasting_n_games(n = 11, p = p, max_round = 11)
}

cod_ps <- tibble(p = seq(0.5, 0.7, by = 0.0025))

cod_theoretical_series_lengths1 <- cod_ps |> 
  mutate(
    theoretical_series_length = map_dbl(p, theoretical_cod_series_length),
    diff = theoretical_series_length - cod_rounds_per_series$actual
  )


cod_theoretical_constant_p1 <- cod_theoretical_series_lengths1 |> 
  slice_min(abs(diff), n = 1) |> 
  pull(p)

pretty_cod_theoretical_constant_p1 <- cod_theoretical_constant_p1 |> 
  scales::percent(accuracy = 0.01)
```

```{r}
#| label: alternative-to-p=0.5-method-1-eval
#| eval: true
pretty_cod_theoretical_constant_p1 <- '57.25%'
```

```{r}
#| label: cod-alternative-to-p=0.5-method-2
pluck_cod_n <- function(.n_rounds) {
  cod_streaks_res$series |>
    filter(n_rounds == .n_rounds) |> 
    pull(n_actual)
}

cod_n6 <- pluck_cod_n(6)
cod_n7 <- pluck_cod_n(7)
cod_n8 <- pluck_cod_n(8)
cod_n9 <- pluck_cod_n(9)
cod_n10 <- pluck_cod_n(10)
cod_n11 <- pluck_cod_n(11)

## This adjustment is something that is not done in the paper. I do it here to reduce
##   the magnitude of the exponents.
cod_pm <- pmin(cod_n6, cod_n7, cod_n8, cod_n9, cod_n10, cod_n11)
cod_n6adj <- round(10 * cod_n6 / cod_pm)
cod_n7adj <- round(10 * cod_n7 / cod_pm)
cod_n8adj <- round(10 * cod_n8 / cod_pm)
cod_n9adj <- round(10 * cod_n9 / cod_pm)
cod_n10adj <- round(10 * cod_n10 / cod_pm)
cod_n11adj <- round(10 * cod_n11 / cod_pm)

maximize_cod_series_p <- function(p) {
  prob_of_series_lasting_n_games(n = 6, p = p, max_round = 11)^cod_n6adj *
    prob_of_series_lasting_n_games(n = 7, p = p, max_round = 11)^cod_n7adj * 
    prob_of_series_lasting_n_games(n = 8, p = p, max_round = 11)^cod_n8adj * 
    prob_of_series_lasting_n_games(n = 9, p = p, max_round = 11)^cod_n9adj *
    prob_of_series_lasting_n_games(n = 10, p = p, max_round = 11)^cod_n10adj * 
    prob_of_series_lasting_n_games(n = 11, p = p, max_round = 11)^cod_n11adj
}

cod_theoretical_series_lengths2 <- cod_ps |> 
  mutate(
    theoretical_series_length = map_dbl(p, maximize_cod_series_p)
  )

cod_theoretical_constant_p2 <- cod_theoretical_series_lengths2 |> 
  slice_max(theoretical_series_length, n = 1, with_ties = FALSE) |> 
  pull(p)

pretty_cod_theoretical_constant_p2 <- cod_theoretical_constant_p2 |> 
  scales::percent(accuracy = 0.01)

best_cod_theoretical_series_lengths2 <- cod_theoretical_series_lengths2 |> 
  filter(p == cod_theoretical_constant_p2)

p_cod_theoretical_series_lengths2 <- cod_theoretical_series_lengths2 |> 
  ggplot() +
  aes(x = p, y = theoretical_series_length) +
  geom_line(
    size = 2,
    color = 'white'
  ) +
  geom_point(
    data = best_cod_theoretical_series_lengths2,
    color = ggsci_cyan,
    size = 6
  ) +
  geom_text(
    data = best_cod_theoretical_series_lengths2,
    color = ggsci_cyan,
    size = 13 / .pt,
    hjust = 0,
    aes(
      x = p + 0.02,
      label = sprintf('Maximum likilihood estimate (MLE) of\nconstant probability of better team winning (%s)', !!pretty_cod_theoretical_constant_p2)
    )
  ) +
  scale_x_continuous(labels = scales::percent) +
  labs(
    x = 'Constant probability of better team winning',
    y = 'Kernel of the multinomial likelihood'
  ) +
  theme(
    axis.text.y = element_blank(),
    panel.grid.major = element_blank()
  )
p_cod_theoretical_series_lengths2
save_plot_for_slide(p_cod_theoretical_series_lengths2)
```

```{r}
#| label: cod-alternative-to-p=0.5-method-2-eval
#| eval: true
pretty_cod_theoretical_constant_p2 <- '53.25%'
```

::: fragment
[Mosteller (1952)](https://math.mit.edu/classes/18.095/2016IAP/lec9/Sports_Mosteller1952_WorldSeries.pdf) suggests several ways to find the optimal constant probability of the "stronger" team winning each game in a series.
:::

::: fragment
-   Using the method of moments approach (Mosteller's method 1), `r pretty_cod_theoretical_constant_p1`
:::

::: fragment
-   Using the maximum likelihood approach (Mosteller's method 2), `r pretty_cod_theoretical_constant_p2`

![](plots/cod_theoretical_series_lengths2.png){fig-align="center" width="65%"}
:::

## When do back-to-back round wins occur?

```{r}
#| label: p_cod_b2b_round_win_prop
summarize_cod_b2b_round_wins <- function(df, ...) {
  df |> 
    arrange(year, sheet, series, team, round) |> 
    group_by(year, sheet, series, team) |> 
    mutate(
      b2b_round_wins = win_round & lag(win_round)
    ) |> 
    ungroup() |> 
    filter(round > 1L) |> 
    count(..., round, b2b_round_wins) |> 
    group_by(..., round) |> 
    mutate(total = sum(n), prop = n / total) |> 
    ungroup() |> 
    filter(b2b_round_wins) |> 
    select(-b2b_round_wins)
}

## now accounting for number of cod_rounds that end up being played...
## seems like there is interesting behavior in the last round, regardless `n_rounds`
cod_b2b_round_win_prop <- cod_rounds |> 
  filter(n_rounds > 6L) |> 
  summarize_cod_b2b_round_wins(n_rounds) |> 
  group_by(n_rounds) |> 
  mutate(
    z = (n - mean(n)) / sd(n),
    rnk = row_number(desc(n))
  ) |> 
  ungroup()

b2b_round_win_prop_tile_layer <- function(..., .df, .round, .palette, .is_new = TRUE) {
  
  init <- if(!.is_new) {
    list()
  } else {
    ggnewscale::new_scale_fill()
  }
  
  list(
    ...,
    init,
    geom_tile(
      data = .df |> filter(n_rounds == .round),
      color = blackish_background,
      height = 0.8,
      show.legend = FALSE,
      aes(
        fill = z,
        x = round + 0.5, 
        y = n_rounds + 0.5
      )
    ),
    ggsci::scale_fill_material(palette = .palette) 
  )
}

b2b_round_win_prop_text_layer <- function(..., .df, .emphasize) {
  if(.emphasize == 'low') {
    op <- `>`
    .color <- blackish_background
  } else {
    op <- `==`
    .color <- 'white'
  }
  list(
    ...,
    geom_text(
      data = .df |> filter(`op`(rnk, 1)),
      color = .color,
      size = 11 / .pt,
      fontface = 'bold',
      aes(
        label = sprintf('%s\n(%s)', scales::percent(prop, accuracy = 1), scales::comma(n)),
        x = round + 0.5, 
        y = n_rounds + 0.5
      )
    )
  )
}

b2b_round_win_prop_text_layers <- function(..., .df) {
  list(
    ...,
    b2b_round_win_prop_text_layer(.df = .df, .emphasize = 'low'),
    b2b_round_win_prop_text_layer(.df = .df, .emphasize = 'high')
  )
}

cod_b2b_round_win_prop_arws <- tibble(
  x = c(9.3, 9.4, 9.75, 10),
  y = c(8.25, 8.5, 8.75, 8.75),
  xend = c(8.1, 9.1, 9.5, 10.5),
  yend = c(7.5, 8.5, 9, 10),
  curvature = c(-0.2, -0.1, 0.1, 0.2)
) |> 
  mutate(
    rn = row_number()
  )

arw <- arrow(length = unit(5, 'pt'), type = 'closed')

p_cod_b2b_round_win_prop <- cod_b2b_round_win_prop |> 
  ggplot() +
  b2b_round_win_prop_tile_layer(
    .df = cod_b2b_round_win_prop, 
    .round = 7, 
    .palette = 'pink', 
    .is_new = FALSE
  ) +
  b2b_round_win_prop_tile_layer(
    .df = cod_b2b_round_win_prop, 
    .round = 8, 
    .palette = 'light-blue'
  ) +
  b2b_round_win_prop_tile_layer(
    .df = cod_b2b_round_win_prop, 
    .round = 9, 
    .palette = 'light-green'
  ) +
  b2b_round_win_prop_tile_layer(
    .df = cod_b2b_round_win_prop, 
    .round = 10, 
    .palette = 'amber'
  ) +
  b2b_round_win_prop_tile_layer(
    .df = cod_b2b_round_win_prop, 
    .round = 11, 
    .palette = 'deep-orange'
  ) +
  b2b_round_win_prop_text_layers(.df = cod_b2b_round_win_prop) +
  scale_x_continuous(
    labels = 2:11,
    breaks = seq(2.5, 11.5, by = 1),
    expand = c(0, 0.5)
  ) +
  scale_y_continuous(
    labels = 7:11,
    breaks = seq(7.5, 11.5, by = 1),
    expand = c(0, 0)
  ) +
  theme(
    panel.grid.major = element_blank(),
    axis.title = element_text(hjust = 0.5),
    plot.title = ggtext::element_markdown(hjust = 0.5),
    axis.text = element_text(size = 16, face = 'bold')
  ) +
  common_cod_labs() +
  labs(
    title = 'Back-to-back round win %',
    x = 'Round',
    y = '# of rounds played in series'
  ) + 
  geom_text(
    data = tibble(
      label = 'Back-to-back wins occur most\nfrequently in the last round.',
      x = 9.5,
      y = 8.5
    ),
    size = 9 / .pt,
    fontface = 'bold',
    color = 'white',
    hjust = 0,
    vjust = 0.5,
    aes(x = x, y = y, label = label)
  ) +
  map(
    cod_b2b_round_win_prop_arws |> group_split(rn), 
    function(.x) {
      geom_curve(
        data = data.frame(),
        color = 'white',
        arrow = arw,
        aes(x = .x$x, y = .x$y, xend = .x$xend, yend = .x$yend),
        curvature = .x$curvature
      )
    }
  )
p_cod_b2b_round_win_prop
save_plot_for_slide(p_cod_b2b_round_win_prop)
# ## now accounting for number of cod_rounds that end up being played AND series winners...
# cod_rounds |> 
#   filter(win_series, n_rounds > 6L) |> 
#   summarize_b2b_round_wins(n_rounds)
# 
# ## and the losers...
# cod_rounds |> 
#   filter(!win_series) |> 
#   summarize_b2b_round_wins(n_rounds)
```

![](plots/cod_b2b_round_win_prop.png){fig-align="center"}

## Is there evidence for the "hot hand"?

::: fragment
[Miller and Sanjurjo (2018)](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2627354) outline a framework for quantifying post-streak success
:::

```{r}
#| label: qs-funcs
#| eval: true
load_qs <- function(name) {
  res <- qs::qread(sprintf('data/%s.qs', name))
  assign(name, value = res, envir = .GlobalEnv)
}
save_qs <- function(df, name = deparse(substitute(df))) {
  qs::qsave(df, sprintf('data/%s.qs', name))
}
```

```{r}
#| label: cod_round_win_prop_after_x_wins
## http://keyonvafa.com/hot-hand/
get_post_streak_prob <- function(n, k, p = 0.5) {
  tosses <- rbinom(n, 1, p)
  runs <- rle(tosses)
  n_neg_after <- length(which(runs$values == 1 & runs$lengths >= k))
  n_pos_after <- sum(runs$lengths[which(runs$values == 1 & runs$lengths >= k)] - k)
  
  ## edge case
  if (n %in% cumsum(runs$lengths)[which(runs$values == 1 & runs$lengths >= k)]) {
    n_neg_after <- n_neg_after - 1
  }
  
  n_pos_after / (n_pos_after + n_neg_after)
}

simulate_post_streak_prob <- function(sims = 10000, seed = 42, ...) {
  withr::local_seed(seed)
  rerun(
    sims,
    get_post_streak_prob(...)
  ) |> 
    flatten_dbl() |> 
    mean(na.rm = TRUE)
}

cod_round_streaks <- cod_rounds |> 
  group_by(series_id, team) |> 
  mutate(
    won_prior_round1 = lag(win_round, n = 1, default = NA),
    won_prior_round2 = lag(win_round, n = 2, default = NA),
    won_prior_round3 = lag(win_round, n = 3, default = NA),
    won_prior_round4 = lag(win_round, n = 4, default = NA),
    won_prior_round5 = lag(win_round, n = 5, default = NA)
  ) |> 
  ungroup() |>
  select(
    series_id,
    team,
    is_offense,
    round,
    n_rounds,
    win_round,
    starts_with('won_prior_round')
  )

.postprocess_round_streaks <- function(k, round_streaks, probs_nx_k, ...) {
  
  cols <- sprintf('won_prior_round%d', 2:k)
  col_syms <- syms(cols)
  round_streaks_after_x <- round_streaks |> 
    drop_na(!!!col_syms) |> 
    count(n_rounds, ..., win_round, won_prior_round1, !!!col_syms, sort = TRUE)
  
  round_win_prop_after_x_wins <- round_streaks_after_x |> 
    filter(won_prior_round1, !!!col_syms)
  
  suppressMessages(
    round_win_prop_after_x_wins_w_probs <- round_win_prop_after_x_wins |> 
      group_by(n_rounds, ...) |> 
      mutate(
        total = sum(n),
        prop = n / total
      ) |> 
      ungroup() |> 
      filter(win_round) |> 
      select(n_rounds, ..., n, total, prop) |> 
      arrange(n_rounds, ...) |> 
      inner_join(
        probs_nx_k
      )
  )
  
  round_win_prop_after_x_wins_w_probs |> 
    nest(data = -c(n_rounds, ...)) |> 
    mutate(
      gt_p_value = map_dbl(
        data, 
        ~binom.test(.x$n, .x$total, .x$expected_poststreak_p, alternative = 'greater') |> 
          broom::tidy() |>
          pull(p.value)
      ),
      lt_p_value = map_dbl(
        data, 
        ~binom.test(.x$n, .x$total, .x$expected_poststreak_p, alternative = 'less') |> 
          broom::tidy() |>
          pull(p.value)
      ),
      gt_is_signif = gt_p_value <= 0.05,
      lt_is_signif = lt_p_value <= 0.05,
      is_signif = case_when(
        gt_is_signif ~ 'Better',
        lt_is_signif ~ 'Worse',
        TRUE ~ 'Neither'
      )
    ) |> 
    unnest(data)
}

summarize_cod_win_prop_after_x_wins <- function(k) {
  probs_nx_k <- tibble(
    n_rounds = 7L:11L
  ) |> 
    mutate(
      prior_p = 6L / n_rounds,
      expected_poststreak_p = map2_dbl(
        n_rounds, prior_p, 
        ~simulate_post_streak_prob(n = ..1, k = !!k, p = ..2)
      )
    )
  
  .postprocess_round_streaks(
    k = k,
    round_streaks = cod_round_streaks,
    probs_nx_k = probs_nx_k
  )
}

cod_round_win_prop_after_x_wins <- tibble(win_streak = 2L:4L) |>
  mutate(
    data = map(win_streak, summarize_cod_win_prop_after_x_wins)
  ) |>
  unnest(data)
save_qs(cod_round_win_prop_after_x_wins)
```

```{r}
#| label: cod_round_win_prop_after_x_wins_and_rounds
summarize_cod_win_prop_after_x_wins_y_rounds <- function(k) {
  probs_nx_k <- crossing(
    n_rounds = 7L:11L,
    round = 3L:11L
  ) |> 
    filter(round >= (k + 1L)) |> 
    mutate(
      prior_p = 6L / n_rounds,
      expected_poststreak_p = map2_dbl(
        n_rounds, prior_p, 
        ~simulate_post_streak_prob(n = ..1, k = !!k, p = ..2)
      )
    )
  
  .postprocess_round_streaks(
    k = k,
    round_streaks = cod_round_streaks,
    probs_nx_k = probs_nx_k,
    round
  )
}

cod_round_win_prop_after_x_wins_y_rounds <- tibble(win_streak = 2L:4L) |>
  mutate(
    data = map(win_streak, summarize_cod_win_prop_after_x_wins_y_rounds)
  ) |>
  unnest(data)
save_qs(cod_round_win_prop_after_x_wins_y_rounds)
```

```{r}
#| label: cod_round_win_prop_after_x_wins-table
#| eval: false
load_qs('cod_round_win_prop_after_x_wins')
cod_round_win_prop_after_x_wins |> 
  transmute(
    `Win Streak` = win_streak,
    `Rounds` = n_rounds,
    `N` = scales::comma(total),
    across(c(prop, expected_poststreak_p), ~scales::percent(.x, accuracy = 0.1)),
    across(
      ends_with('p_value'), 
      ~case_when(
        .x <= 0.01 ~ '<=0.01', 
        round(.x, 2) == 1 ~ '1',
        TRUE ~ as.character(round(.x, 2))
      )
    )
  ) |>
  rename(
    `Actual post-streak win %` = prop,
    `Expected post-streak win %` = expected_poststreak_p,
    `Binom. > p-value` = gt_p_value,
    `Binom. < p-value` = lt_p_value
  ) |> 
  knitr::kable()
```

```{r}
#| label: cod_round_win_prop_after_x_wins-plot
load_qs('cod_round_win_prop_after_x_wins')

ggsci_grey <- extract_ggsci_mid_color('grey')
p_cod_round_win_prop_after_x_wins <- cod_round_win_prop_after_x_wins |> 
  ggplot() +
  geom_tile(
    color = blackish_background,
    height = 0.8,
    aes(
      fill = lt_is_signif,
      y = win_streak + 0.5, 
      x = n_rounds + 0.5
    )
  ) +
  geom_richtext(
    fill = NA_character_,
    label.color = NA_character_,
    family = font,
    color = blackish_background,
    size = 11 / .pt,
    fontface = 'bold',
    aes(
      label = sprintf(
        '%s %s <span style="color:white">%s</span><br/>(%s)',
        scales::percent(prop, accuracy = 1), 
        case_when(
          round(prop, 1) == round(expected_poststreak_p, 1) ~ '=',
          prop >= expected_poststreak_p ~ '>=', 
          TRUE ~ '<'
        ),
        scales::percent(expected_poststreak_p, accuracy = 1),
        scales::comma(n)
      ),
      y = win_streak + 0.5, 
      x = n_rounds + 0.5
    )
  ) +
  guides(
    fill = guide_legend(
      'Significantly less than expected?'
    )
  ) +
  scale_y_continuous(
    labels = 2:4,
    breaks = seq(2.5, 4.5, by = 1),
    expand = c(0, 0.5)
  ) +
  scale_x_continuous(
    labels = 7:11,
    breaks = seq(7.5, 11.5, by = 1),
    expand = c(0, 0)
  ) +
  scale_fill_manual(
    values = c(ggsci_grey, ggsci_cyan),
    labels = c('No', 'Yes')
  ) +
  theme(
    legend.position = 'top',
    legend.text = element_text(color = 'white', size = 12),
    panel.grid.major = element_blank(),
    axis.title = element_text(hjust = 0.5),
    plot.title = ggtext::element_markdown(hjust = 0.5),
    axis.text = element_text(size = 16, face = 'bold')
  ) +
  common_cod_labs() +
  labs(
    title = 'Post win streak round win %',
    y = 'Win streak length',
    x = '# of rounds played in series'
  ) +
  geom_curve(
    data = data.frame(),
    color = 'white',
    arrow = arw,
    curvature = 0.1,
    aes(
      x = 7.8,
      y = 5.11,
      xend = 7.7,
      yend = 4.8
    )
  ) +
  geom_text(
    data = data.frame(),
    hjust = 0,
    vjust = 0.5,
    color = 'white',
    size = 12 / .pt,
    aes(
      label = 'Expected %',
      x = 7.81,
      y = 5.12
    )
  ) +
  geom_curve(
    data = data.frame(),
    color = 'white',
    arrow = arw,
    curvature = 0.25,
    aes(
      x = 7.8,
      y = 5.41,
      xend = 7.3,
      yend = 4.8
    )
  ) +
  geom_text(
    data = data.frame(),
    hjust = 0,
    vjust = 0.5,
    color = 'white',
    size = 12 / .pt,
    aes(
      label = 'Actual %',
      x = 7.81,
      y = 5.42
    )
  )
p_cod_round_win_prop_after_x_wins
save_plot_for_slide(p_cod_round_win_prop_after_x_wins)
```

::: fragment
![](plots/cod_round_win_prop_after_x_wins.png)

-   There is no evidence for momentum, for both streaks of 2 and 3. In fact, for series that go to 9, 10, or 11 rounds, there is evidence that the streaking teams perform significantly worse than expected in the post-streak round. And for streaks of 4, teams perform worse than expected in series ending in 7, 8, 10, and 11 rounds.
:::

```{r}
load_qs('cod_round_win_prop_after_x_wins_y_rounds')
ggsci_orange <- extract_ggsci_mid_color('orange')
p_cod_round_win_prop_after_x_wins_y_rounds <- cod_round_win_prop_after_x_wins_y_rounds |> 
  filter(win_streak == 3) |> 
  mutate(
    is_signif = case_when(
      gt_is_signif ~ 'Better',
      lt_is_signif ~ 'Worse',
      TRUE ~ 'Neither'
    )
  ) |> 
  # filter(win_streak %in% c(3, 4)) |> 
  # filter(n >= 20) |> 
  ggplot() +
  geom_tile(
    color = blackish_background,
    height = 0.8,
    aes(
      fill = is_signif,
      x = round + 0.5, 
      y = n_rounds + 0.5
    )
  ) +
  geom_richtext(
    fill = NA_character_,
    label.color = NA_character_,
    family = font,
    color = blackish_background,
    size = 11 / .pt,
    fontface = 'bold',
    aes(
      label = sprintf(
        '%s %s <span style="color:white">%s</span><br/>(%s)',
        scales::percent(prop, accuracy = 1), 
        case_when(
          round(prop, 1) == round(expected_poststreak_p, 1) ~ '=',
          prop >= expected_poststreak_p ~ '>=', 
          TRUE ~ '<'
        ),
        scales::percent(expected_poststreak_p, accuracy = 1),
        scales::comma(n)
      ),
      x = round + 0.5, 
      y = n_rounds + 0.5
    )
  ) +
  guides(
    fill = guide_legend(
      'Significantly better/worse?'
    )
  ) +
  scale_x_continuous(
    labels = 4:11,
    breaks = seq(4.5, 11.5, by = 1),
    expand = c(0, 0.5)
  ) +
  scale_y_continuous(
    labels = 7:11,
    breaks = seq(7.5, 11.5, by = 1),
    expand = c(0, 0)
  ) +
  scale_fill_manual(
    values = c(ggsci_cyan, ggsci_grey, ggsci_orange),
    labels = c('Better', 'Neither', 'Worse')
  ) +
  theme(
    legend.position = 'top',
    legend.text = element_text(color = 'white', size = 12),
    panel.grid.major = element_blank(),
    axis.title = element_text(hjust = 0.5),
    plot.title = ggtext::element_markdown(hjust = 0.5),
    axis.text = element_text(size = 16, face = 'bold')
  ) +
  common_cod_labs() +
  labs(
    title = 'Post win streak round win %',
    x = 'Round',
    y = '# of rounds played in series'
  ) +
  facet_wrap(~win_streak)
p_cod_round_win_prop_after_x_wins_y_rounds
save_plot_for_slide(p_cod_round_win_prop_after_x_wins_y_rounds)
```

## Is planting at one site better than the other?

```{r}
#| label: cod_plant_win_prop_proj
cod_map_plant_win_prop <- cod_rounds |> 
  filter(!is.na(plant)) |> 
  filter(is_offense) |> 
  group_by(year, game, map, plant) |> 
  summarize(
    n = n(),
    wins = sum(win_round)
  ) |> 
  ungroup() |> 
  mutate(
    win_prop = wins / n
  ) |> 
  group_by(year, game, map) |> 
  mutate(
    total = sum(n),
    rnk = row_number(-n),
    prop = n / total
  ) |> 
  ungroup()

cod_plant_win_prop <- cod_map_plant_win_prop |>
  mutate(site = ifelse(rnk == 1, 'pri', 'sec')) |> 
  group_by(site) |> 
  summarize(
    across(c(n, wins, total), sum)
  ) |> 
  ungroup() |> 
  mutate(
    win_prop = wins / n,
    prop = n / total
  )

cod_plant_win_prop_proj <- cod_plant_win_prop |> 
  left_join(
    cod_rounds |> 
      filter(is_offense) |> 
      filter(is.na(plant)) |> 
      summarize(
        n_no_plant = n(),
        wins_no_plant = sum(win_round)
      ),
    by = character()
  ) |> 
  mutate(
    n_proj = round(n + prop * n_no_plant),
    wins_proj = round(wins + prop * wins_no_plant),
    win_prop_proj = wins_proj / n_proj
  )

cod_plant_site_prop <- cod_plant_win_prop_proj |> 
  select(site, prop) |> 
  deframe() |> 
  scales::percent(accuracy = 0.1)

cod_plant_site_win_prop <- cod_plant_win_prop_proj |> 
  select(site, win_prop_proj) |> 
  deframe() |> 
  scales::percent(accuracy = 0.1)
```

```{r}
#| label: cod_plant_win_prop_proj-eval
#| eval: true
cod_plant_site_prop <- c(
  'pri' = '60.9%',
  'sec' = '39.1%'
)
cod_plant_site_win_prop <- c(
  'pri' = '47.4%',
  'sec' = '48.5%'
)
```

<br/><br/>

::: columns
::: {.column width="15%"}
:::

::: {.column .fragment width="30%"}
| Plant site |                               \% |
|------------|---------------------------------:|
| Primary    | `r cod_plant_site_prop[['pri']]` |
| Secondary  | `r cod_plant_site_prop[['sec']]` |
:::

::: {.column width="10%"}
:::

::: {.column .fragment width="30%"}
| Plant site |                                Win % |
|------------|-------------------------------------:|
| Primary    | `r cod_plant_site_win_prop[['pri']]` |
| Secondary  | `r cod_plant_site_win_prop[['sec']]` |
:::

::: {.column width="15%"}
:::
:::

## Are offensive win %'s different in round 1?

```{r}
#| label: p_cod_o_win_r1_vs_post_round_prop
calculate_map_o_round_win_prop <- function(df) {
  df |> 
    count(map, is_offense, win_round) |> 
    group_by(map, is_offense) |> 
    mutate(total = sum(n), prop = n / total) |> 
    ungroup() |>
    filter(win_round, is_offense) |>
    select(
      map,
      rounds_won = n,
      total_rounds = total,
      win_round_prop = prop
    ) |>
    arrange(desc(win_round_prop))
}

summarize_map_o_round_win_prop <- function(df, .round) {
  
  specified_round <- df |> 
    filter(round == .round) |> 
    calculate_map_o_round_win_prop()
  
  post_rounds <- df |> 
    filter(round > .round) |> 
    calculate_map_o_round_win_prop()
  
  specified_round |> 
    inner_join(
      post_rounds |> rename_with(~sprintf('post_%s', .x), -c(map)),
      by = 'map'
    ) |> 
    mutate(round = .round, .after = 'map') |> 
    arrange(desc(win_round_prop)) |> 
    mutate(
      prop_test = vectorized_prop_test(rounds_won, total_rounds, post_rounds_won, post_total_rounds),
      p_value = prop_test$p.value
    ) |> 
    arrange(p_value) |> 
    mutate(
      diff_prop = post_win_round_prop - win_round_prop,
      dir = factor(sign(diff_prop)),
      is_significant = p_value < 0.05
    )
}

o_win_rx_prop_pal <- c(
  `-1` = extract_ggsci_mid_color('pink'),
  `1` = extract_ggsci_mid_color('teal')
)

plot_round_vs_post_round_slope_chart <- function(df, .round) {
  o_win_rx_prop <- summarize_map_o_round_win_prop(df, .round)
  x1_label <- sprintf('Round %d<br/>offensive win %%', .round)
  x2_label <- sprintf('Post-round %d<br/>offensive win %%', .round)
  
  min_o_win_rx_prop <- o_win_rx_prop |> slice_min(diff_prop, n = 1)
  max_o_win_rx_prop <- o_win_rx_prop |> slice_max(diff_prop, n = 1)
  minmax_maps <- c(min_o_win_rx_prop$map, max_o_win_rx_prop$map)
  
  y_lo <- 0.25
  y_hi <- 0.75
  
  
  p <- o_win_rx_prop |> 
    ggplot() +
    geom_vline(
      data = tibble(),
      aes(xintercept = c(1, 2)), 
      color = gray_points
    ) +
    geom_hline(
      data = tibble(),
      aes(yintercept = c(y_lo, 0.5, y_hi)), 
      linetype = 2,
      color = gray_points
    ) +
    geom_segment(
      data = o_win_rx_prop |> 
        mutate(
          big_segment = map %in% minmax_maps
        ),
      show.legend = FALSE,
      aes(
        x = 1,
        xend = 2,
        y = win_round_prop,
        yend = post_win_round_prop,
        color = dir,
        size = big_segment,
        group = map
      )
    ) +
    geom_text(
      data = tibble(
        y = c(y_lo, y_hi)
      ) |> 
        mutate(
          lab = sprintf('%s%%', round(100 * y))
        ),
      aes(x = 2, y = y, label = lab), 
      size = 12 / .pt,
      hjust = -0.05,
      vjust = -0.25,
      fontface = 'bold',
      color = 'white'
    ) +
    ggtext::geom_richtext(
      fill = blackish_background, 
      label.color = NA,
      data = tibble(
        x = c(1, 2),
        y = rep(0.7, 2),
        lab = c(x1_label, x2_label)
      ),
      aes(x = x, y = y, label = lab), 
      size = 9 / .pt,
      hjust = 0.5,
      vjust = 0.5,
      family = font,
      fontface = 'bold',
      color = 'white'
    ) +
    ggrepel::geom_text_repel(
      data = o_win_rx_prop |> 
        filter(map %in% !!minmax_maps),
      aes(x = 1, y = win_round_prop, label = map),
      family = font,
      fontface = 'bold',
      color = 'white',
      size = 9 / .pt,
      hjust = 'right', 
      nudge_x = -0.1,
      direction = 'y'
    ) +
    ggrepel::geom_text_repel(
      data = o_win_rx_prop |> 
        filter(!(map %in% !!minmax_maps)),
      aes(x = 2, y = post_win_round_prop, label = map),
      family = font,
      color = gray_text,
      size = 9 / .pt,
      hjust = 'left', 
      nudge_x = 0.1,
      direction = 'y'
    ) +
    scale_x_continuous(
      position = 'top',
      breaks = c(1, 2),
      expand = expansion(mult = 0.5)
    ) +
    scale_y_continuous(
      limits = c(y_lo, y_hi)
    ) +
    scale_size_manual(
      values = c(
        `FALSE` = 0.5,
        `TRUE` = 2
      )
    ) +
    scale_color_manual(
      name = NULL,
      values = o_win_rx_prop_pal
    ) +
    theme(
      plot.title = element_text(hjust = 0.5),
      panel.grid.major = element_blank(),
      axis.text.x = element_blank(),
      axis.text.y = element_blank()
    ) +
    labs(
      x = NULL,
      y = NULL
    )
  list(
    plot = p,
    data = o_win_rx_prop,
    largest_neg_diff_prop = min_o_win_rx_prop$diff_prop,
    largest_pos_diff_prop = max_o_win_rx_prop$diff_prop
  )
}

cod_res_r1 <- cod_rounds |> 
  plot_round_vs_post_round_slope_chart(1)

p_cod_o_win_r1_vs_post_round_prop <- cod_res_r1$plot +
  geom_curve(
    data = tibble(),
    aes(x = 1.2, y = 0.65, xend = 1.1, yend = 0.63),
    curvature = 0.2, 
    color = o_win_rx_prop_pal[["-1"]], 
    arrow = arw
  ) +
  geom_curve(
    data = tibble(),
    aes(x = 1.24, y = 0.27, xend = 1.1, yend = 0.27),
    curvature = 0-.2, 
    color = o_win_rx_prop_pal[["1"]], 
    arrow = arw
  ) +
  geom_text(
    data = tibble(
      x = c(1.2, 1.24),
      y = c(0.65, 0.27),
      hjust = c(0, 0),
      vjust = c(0.5, 0.5),
      lab = c(
        sprintf(
          'Largest negative percent difference in round 1\nvs. all other round win percentages (%+.0f%%).', 
          100 * cod_res_r1$largest_neg_diff_prop
        ),
        sprintf(
          'Largest positive percent difference (%+.0f%%).\nOnly significant difference (p value < 0.01).',
          100 * cod_res_r1$largest_pos_diff_prop
        )
      )
    ),
    color = 'white',
    size = 9 / .pt,
    aes(x = x, y = y, hjust = hjust, vjust = vjust, label = lab)
  ) +
  common_cod_labs()
p_cod_o_win_r1_vs_post_round_prop
save_plot_for_slide(p_cod_o_win_r1_vs_post_round_prop)
```

![](plots/cod_o_win_r1_vs_post_round_prop.png){fig-align="center"}
